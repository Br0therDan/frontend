/* tslint:disable */
/* eslint-disable */
/**
 * MySingle - Posts -(dev)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
	BASE_PATH,
	COLLECTION_FORMATS,
	BaseAPI,
	RequiredError,
	operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface CategoryCreate
 */
export interface CategoryCreate {
	/**
	 *
	 * @type {string}
	 * @memberof CategoryCreate
	 */
	name: string;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof CategoryCreate
	 */
	subcategories?: Array<string>;
}
/**
 *
 * @export
 * @interface CategoryPublic
 */
export interface CategoryPublic {
	/**
	 *
	 * @type {string}
	 * @memberof CategoryPublic
	 */
	_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryPublic
	 */
	name: string;
	/**
	 *
	 * @type {Array<SubcategoryPublic>}
	 * @memberof CategoryPublic
	 */
	subcategories?: Array<SubcategoryPublic>;
}
/**
 *
 * @export
 * @interface CategoryUpdate
 */
export interface CategoryUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof CategoryUpdate
	 */
	_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof CategoryUpdate
	 */
	subcategories?: Array<string> | null;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
	/**
	 *
	 * @type {Array<ValidationError>}
	 * @memberof HTTPValidationError
	 */
	detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
	/**
	 *
	 * @type {string}
	 * @memberof Message
	 */
	message: string;
}
/**
 *
 * @export
 * @interface PostCreate
 */
export interface PostCreate {
	/**
	 *
	 * @type {string}
	 * @memberof PostCreate
	 */
	title?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof PostCreate
	 */
	content?: string | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof PostCreate
	 */
	is_public?: boolean | null;
	/**
	 *
	 * @type {string}
	 * @memberof PostCreate
	 */
	category_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof PostCreate
	 */
	subcategory_id?: string | null;
}
/**
 *
 * @export
 * @interface PostPublic
 */
export interface PostPublic {
	/**
	 *
	 * @type {string}
	 * @memberof PostPublic
	 */
	_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof PostPublic
	 */
	title: string;
	/**
	 *
	 * @type {string}
	 * @memberof PostPublic
	 */
	content: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof PostPublic
	 */
	is_public: boolean;
	/**
	 *
	 * @type {CategoryPublic}
	 * @memberof PostPublic
	 */
	category?: CategoryPublic | null;
	/**
	 *
	 * @type {SubcategoryPublic}
	 * @memberof PostPublic
	 */
	subcategory?: SubcategoryPublic | null;
	/**
	 *
	 * @type {string}
	 * @memberof PostPublic
	 */
	author: string;
	/**
	 *
	 * @type {string}
	 * @memberof PostPublic
	 */
	created_at?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof PostPublic
	 */
	updated_at?: string | null;
}
/**
 *
 * @export
 * @interface PostUpdate
 */
export interface PostUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof PostUpdate
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof PostUpdate
	 */
	title?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof PostUpdate
	 */
	content?: string | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof PostUpdate
	 */
	is_public?: boolean | null;
	/**
	 *
	 * @type {string}
	 * @memberof PostUpdate
	 */
	category_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof PostUpdate
	 */
	subcategory_id?: string | null;
}
/**
 *
 * @export
 * @interface SubcategoryPublic
 */
export interface SubcategoryPublic {
	/**
	 *
	 * @type {string}
	 * @memberof SubcategoryPublic
	 */
	_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof SubcategoryPublic
	 */
	name: string;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
	/**
	 *
	 * @type {Array<ValidationErrorLocInner>}
	 * @memberof ValidationError
	 */
	loc: Array<ValidationErrorLocInner>;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	msg: string;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	type: string;
}
/**
 *
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {}

/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary 새로운 카테고리(서브카테고리 포함) 생성
		 * @param {CategoryCreate} categoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoriesCreateCategory: async (
			categoryCreate: CategoryCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryCreate' is not null or undefined
			assertParamExists(
				"categoriesCreateCategory",
				"categoryCreate",
				categoryCreate,
			);
			const localVarPath = `/api/v1/categories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				categoryCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary 카테고리 및 해당 서브카테고리 삭제
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoriesDeleteCategory: async (
			categoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists("categoriesDeleteCategory", "categoryId", categoryId);
			const localVarPath = `/api/v1/categories/{category_id}`.replace(
				`{${"category_id"}}`,
				encodeURIComponent(String(categoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary 전체 카테고리(서브카테고리 포함) 조회
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoriesReadCategories: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/categories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary 카테고리 정보 업데이트
		 * @param {string} categoryId
		 * @param {CategoryUpdate} categoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoriesUpdateCategory: async (
			categoryId: string,
			categoryUpdate: CategoryUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists("categoriesUpdateCategory", "categoryId", categoryId);
			// verify required parameter 'categoryUpdate' is not null or undefined
			assertParamExists(
				"categoriesUpdateCategory",
				"categoryUpdate",
				categoryUpdate,
			);
			const localVarPath = `/api/v1/categories/{category_id}`.replace(
				`{${"category_id"}}`,
				encodeURIComponent(String(categoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				categoryUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		CategoriesApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary 새로운 카테고리(서브카테고리 포함) 생성
		 * @param {CategoryCreate} categoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async categoriesCreateCategory(
			categoryCreate: CategoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryPublic>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.categoriesCreateCategory(
					categoryCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CategoriesApi.categoriesCreateCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary 카테고리 및 해당 서브카테고리 삭제
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async categoriesDeleteCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.categoriesDeleteCategory(
					categoryId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CategoriesApi.categoriesDeleteCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary 전체 카테고리(서브카테고리 포함) 조회
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async categoriesReadCategories(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<CategoryPublic>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.categoriesReadCategories(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CategoriesApi.categoriesReadCategories"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary 카테고리 정보 업데이트
		 * @param {string} categoryId
		 * @param {CategoryUpdate} categoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async categoriesUpdateCategory(
			categoryId: string,
			categoryUpdate: CategoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryPublic>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.categoriesUpdateCategory(
					categoryId,
					categoryUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CategoriesApi.categoriesUpdateCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = CategoriesApiFp(configuration);
	return {
		/**
		 *
		 * @summary 새로운 카테고리(서브카테고리 포함) 생성
		 * @param {CategoryCreate} categoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoriesCreateCategory(
			categoryCreate: CategoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CategoryPublic> {
			return localVarFp
				.categoriesCreateCategory(categoryCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary 카테고리 및 해당 서브카테고리 삭제
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoriesDeleteCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.categoriesDeleteCategory(categoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary 전체 카테고리(서브카테고리 포함) 조회
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoriesReadCategories(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<CategoryPublic>> {
			return localVarFp
				.categoriesReadCategories(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary 카테고리 정보 업데이트
		 * @param {string} categoryId
		 * @param {CategoryUpdate} categoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoriesUpdateCategory(
			categoryId: string,
			categoryUpdate: CategoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<CategoryPublic> {
			return localVarFp
				.categoriesUpdateCategory(
					categoryId,
					categoryUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
	/**
	 *
	 * @summary 새로운 카테고리(서브카테고리 포함) 생성
	 * @param {CategoryCreate} categoryCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoriesApi
	 */
	public categoriesCreateCategory(
		categoryCreate: CategoryCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CategoriesApiFp(this.configuration)
			.categoriesCreateCategory(categoryCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary 카테고리 및 해당 서브카테고리 삭제
	 * @param {string} categoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoriesApi
	 */
	public categoriesDeleteCategory(
		categoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CategoriesApiFp(this.configuration)
			.categoriesDeleteCategory(categoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary 전체 카테고리(서브카테고리 포함) 조회
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoriesApi
	 */
	public categoriesReadCategories(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CategoriesApiFp(this.configuration)
			.categoriesReadCategories(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary 카테고리 정보 업데이트
	 * @param {string} categoryId
	 * @param {CategoryUpdate} categoryUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoriesApi
	 */
	public categoriesUpdateCategory(
		categoryId: string,
		categoryUpdate: CategoryUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CategoriesApiFp(this.configuration)
			.categoriesUpdateCategory(
				categoryId,
				categoryUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * PostsApi - axios parameter creator
 * @export
 */
export const PostsApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary 새로운 포스트 생성
		 * @param {PostCreate} postCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsCreatePost: async (
			postCreate: PostCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'postCreate' is not null or undefined
			assertParamExists("postsCreatePost", "postCreate", postCreate);
			const localVarPath = `/api/v1/posts/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				postCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary 포스트 삭제
		 * @param {string} postId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsDeletePost: async (
			postId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'postId' is not null or undefined
			assertParamExists("postsDeletePost", "postId", postId);
			const localVarPath = `/api/v1/posts/{post_id}`.replace(
				`{${"post_id"}}`,
				encodeURIComponent(String(postId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 사용자의 글 관리를 위한 포스트 조회
		 * @summary 내 글 조회
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsReadMyPosts: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/posts/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary 특정 포스트 조회
		 * @param {string} postId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsReadPost: async (
			postId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'postId' is not null or undefined
			assertParamExists("postsReadPost", "postId", postId);
			const localVarPath = `/api/v1/posts/{post_id}`.replace(
				`{${"post_id"}}`,
				encodeURIComponent(String(postId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 전체 Public 포스트를 조회합니다.
		 * @summary 전체 공개 포스트를 조회
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsReadPublicPosts: async (
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/posts/public`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary 포스트 정보 업데이트
		 * @param {string} postId
		 * @param {PostUpdate} postUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsUpdatePost: async (
			postId: string,
			postUpdate: PostUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'postId' is not null or undefined
			assertParamExists("postsUpdatePost", "postId", postId);
			// verify required parameter 'postUpdate' is not null or undefined
			assertParamExists("postsUpdatePost", "postUpdate", postUpdate);
			const localVarPath = `/api/v1/posts/{post_id}`.replace(
				`{${"post_id"}}`,
				encodeURIComponent(String(postId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				postUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * PostsApi - functional programming interface
 * @export
 */
export const PostsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = PostsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary 새로운 포스트 생성
		 * @param {PostCreate} postCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsCreatePost(
			postCreate: PostCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostPublic>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.postsCreatePost(
				postCreate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["PostsApi.postsCreatePost"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary 포스트 삭제
		 * @param {string} postId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsDeletePost(
			postId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.postsDeletePost(
				postId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["PostsApi.postsDeletePost"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 사용자의 글 관리를 위한 포스트 조회
		 * @summary 내 글 조회
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsReadMyPosts(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<PostPublic>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postsReadMyPosts(accessToken, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["PostsApi.postsReadMyPosts"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary 특정 포스트 조회
		 * @param {string} postId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsReadPost(
			postId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostPublic>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.postsReadPost(
				postId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["PostsApi.postsReadPost"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 전체 Public 포스트를 조회합니다.
		 * @summary 전체 공개 포스트를 조회
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsReadPublicPosts(
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<PostPublic>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.postsReadPublicPosts(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["PostsApi.postsReadPublicPosts"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary 포스트 정보 업데이트
		 * @param {string} postId
		 * @param {PostUpdate} postUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async postsUpdatePost(
			postId: string,
			postUpdate: PostUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostPublic>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.postsUpdatePost(
				postId,
				postUpdate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["PostsApi.postsUpdatePost"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * PostsApi - factory interface
 * @export
 */
export const PostsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = PostsApiFp(configuration);
	return {
		/**
		 *
		 * @summary 새로운 포스트 생성
		 * @param {PostCreate} postCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsCreatePost(
			postCreate: PostCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<PostPublic> {
			return localVarFp
				.postsCreatePost(postCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary 포스트 삭제
		 * @param {string} postId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsDeletePost(
			postId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.postsDeletePost(postId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 사용자의 글 관리를 위한 포스트 조회
		 * @summary 내 글 조회
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsReadMyPosts(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<PostPublic>> {
			return localVarFp
				.postsReadMyPosts(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary 특정 포스트 조회
		 * @param {string} postId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsReadPost(
			postId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<PostPublic> {
			return localVarFp
				.postsReadPost(postId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 전체 Public 포스트를 조회합니다.
		 * @summary 전체 공개 포스트를 조회
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsReadPublicPosts(
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<PostPublic>> {
			return localVarFp
				.postsReadPublicPosts(options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary 포스트 정보 업데이트
		 * @param {string} postId
		 * @param {PostUpdate} postUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		postsUpdatePost(
			postId: string,
			postUpdate: PostUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<PostPublic> {
			return localVarFp
				.postsUpdatePost(postId, postUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * PostsApi - object-oriented interface
 * @export
 * @class PostsApi
 * @extends {BaseAPI}
 */
export class PostsApi extends BaseAPI {
	/**
	 *
	 * @summary 새로운 포스트 생성
	 * @param {PostCreate} postCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsCreatePost(
		postCreate: PostCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return PostsApiFp(this.configuration)
			.postsCreatePost(postCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary 포스트 삭제
	 * @param {string} postId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsDeletePost(
		postId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return PostsApiFp(this.configuration)
			.postsDeletePost(postId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 사용자의 글 관리를 위한 포스트 조회
	 * @summary 내 글 조회
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsReadMyPosts(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return PostsApiFp(this.configuration)
			.postsReadMyPosts(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary 특정 포스트 조회
	 * @param {string} postId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsReadPost(
		postId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return PostsApiFp(this.configuration)
			.postsReadPost(postId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 전체 Public 포스트를 조회합니다.
	 * @summary 전체 공개 포스트를 조회
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsReadPublicPosts(options?: RawAxiosRequestConfig) {
		return PostsApiFp(this.configuration)
			.postsReadPublicPosts(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary 포스트 정보 업데이트
	 * @param {string} postId
	 * @param {PostUpdate} postUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PostsApi
	 */
	public postsUpdatePost(
		postId: string,
		postUpdate: PostUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return PostsApiFp(this.configuration)
			.postsUpdatePost(postId, postUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
