/* tslint:disable */
/* eslint-disable */
/**
 * MySingle - Location Service (dev)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
	BASE_PATH,
	COLLECTION_FORMATS,
	BaseAPI,
	RequiredError,
	operationServerMap,
} from "./base";

/**
 * 사용자에게 전달되는 알림
 * @export
 * @interface AlertInput
 */
export interface AlertInput {
	/**
	 *
	 * @type {string}
	 * @memberof AlertInput
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AlertInput
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof AlertInput
	 */
	updated_at?: string;
	/**
	 *
	 * @type {AlertType}
	 * @memberof AlertInput
	 */
	type: AlertType;
	/**
	 *
	 * @type {string}
	 * @memberof AlertInput
	 */
	user_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof AlertInput
	 */
	community_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof AlertInput
	 */
	safezone_id: string | null;
	/**
	 *
	 * @type {GeoPoint}
	 * @memberof AlertInput
	 */
	location: GeoPoint | null;
	/**
	 *
	 * @type {string}
	 * @memberof AlertInput
	 */
	message: string | null;
	/**
	 *
	 * @type {object}
	 * @memberof AlertInput
	 */
	data?: object;
	/**
	 *
	 * @type {boolean}
	 * @memberof AlertInput
	 */
	is_read?: boolean;
}

/**
 * 사용자에게 전달되는 알림
 * @export
 * @interface AlertOutput
 */
export interface AlertOutput {
	/**
	 *
	 * @type {string}
	 * @memberof AlertOutput
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AlertOutput
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof AlertOutput
	 */
	updated_at?: string;
	/**
	 *
	 * @type {AlertType}
	 * @memberof AlertOutput
	 */
	type: AlertType;
	/**
	 *
	 * @type {string}
	 * @memberof AlertOutput
	 */
	user_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof AlertOutput
	 */
	community_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof AlertOutput
	 */
	safezone_id: string | null;
	/**
	 *
	 * @type {GeoPoint}
	 * @memberof AlertOutput
	 */
	location: GeoPoint | null;
	/**
	 *
	 * @type {string}
	 * @memberof AlertOutput
	 */
	message: string | null;
	/**
	 *
	 * @type {object}
	 * @memberof AlertOutput
	 */
	data?: object;
	/**
	 *
	 * @type {boolean}
	 * @memberof AlertOutput
	 */
	is_read?: boolean;
}

/**
 * 알림 유형
 * @export
 * @enum {string}
 */

export const AlertType = {
	Info: "info",
	Emergency: "emergency",
	SafezoneExit: "safezone_exit",
	SafezoneEntry: "safezone_entry",
	LocationRequest: "location_request",
	LocationSharing: "location_sharing",
} as const;

export type AlertType = (typeof AlertType)[keyof typeof AlertType];

/**
 *
 * @export
 * @interface CommunityCreate
 */
export interface CommunityCreate {
	/**
	 *
	 * @type {string}
	 * @memberof CommunityCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CommunityCreate
	 */
	description: string;
}
/**
 *
 * @export
 * @interface CommunityPublic
 */
export interface CommunityPublic {
	/**
	 *
	 * @type {string}
	 * @memberof CommunityPublic
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof CommunityPublic
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CommunityPublic
	 */
	description: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof CommunityPublic
	 */
	created_at: string;
	/**
	 *
	 * @type {string}
	 * @memberof CommunityPublic
	 */
	updated_at: string;
	/**
	 *
	 * @type {string}
	 * @memberof CommunityPublic
	 */
	owner_id: string;
	/**
	 *
	 * @type {Array<MemberPublic>}
	 * @memberof CommunityPublic
	 */
	members?: Array<MemberPublic> | null;
	/**
	 *
	 * @type {Array<SafezonePublic>}
	 * @memberof CommunityPublic
	 */
	safezones?: Array<SafezonePublic> | null;
}
/**
 *
 * @export
 * @interface CommunityUpdate
 */
export interface CommunityUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof CommunityUpdate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CommunityUpdate
	 */
	description: string;
}
/**
 *
 * @export
 * @interface GeoPoint
 */
export interface GeoPoint {
	/**
	 *
	 * @type {number}
	 * @memberof GeoPoint
	 */
	latitude: number;
	/**
	 *
	 * @type {number}
	 * @memberof GeoPoint
	 */
	longitude: number;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
	/**
	 *
	 * @type {Array<ValidationError>}
	 * @memberof HTTPValidationError
	 */
	detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface LocationLog
 */
export interface LocationLog {
	/**
	 *
	 * @type {string}
	 * @memberof LocationLog
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof LocationLog
	 */
	user_id: string;
	/**
	 *
	 * @type {number}
	 * @memberof LocationLog
	 */
	latitude: number;
	/**
	 *
	 * @type {number}
	 * @memberof LocationLog
	 */
	longitude: number;
	/**
	 *
	 * @type {number}
	 * @memberof LocationLog
	 */
	accuracy?: number | null;
	/**
	 *
	 * @type {string}
	 * @memberof LocationLog
	 */
	timestamp?: string;
}
/**
 *
 * @export
 * @interface LocationUpdate
 */
export interface LocationUpdate {
	/**
	 *
	 * @type {number}
	 * @memberof LocationUpdate
	 */
	latitude: number;
	/**
	 *
	 * @type {number}
	 * @memberof LocationUpdate
	 */
	longitude: number;
	/**
	 *
	 * @type {number}
	 * @memberof LocationUpdate
	 */
	accuracy?: number | null;
}
/**
 *
 * @export
 * @interface Member
 */
export interface Member {
	/**
	 *
	 * @type {string}
	 * @memberof Member
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Member
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Member
	 */
	updated_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Member
	 */
	username?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Member
	 */
	email: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof Member
	 */
	is_parent?: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof Member
	 */
	is_confirmed?: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof Member
	 */
	community_id: string;
}
/**
 *
 * @export
 * @interface MemberAdd
 */
export interface MemberAdd {
	/**
	 *
	 * @type {string}
	 * @memberof MemberAdd
	 */
	email: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof MemberAdd
	 */
	is_parent?: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof MemberAdd
	 */
	is_confirmed?: boolean;
}
/**
 *
 * @export
 * @interface MemberConfirm
 */
export interface MemberConfirm {
	/**
	 *
	 * @type {string}
	 * @memberof MemberConfirm
	 */
	user_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof MemberConfirm
	 */
	email: string;
}
/**
 *
 * @export
 * @interface MemberPublic
 */
export interface MemberPublic {
	/**
	 *
	 * @type {string}
	 * @memberof MemberPublic
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof MemberPublic
	 */
	username: string;
	/**
	 *
	 * @type {string}
	 * @memberof MemberPublic
	 */
	email: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof MemberPublic
	 */
	is_parent: boolean;
	/**
	 *
	 * @type {boolean}
	 * @memberof MemberPublic
	 */
	is_confirmed: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof MemberPublic
	 */
	created_at: string;
	/**
	 *
	 * @type {string}
	 * @memberof MemberPublic
	 */
	updated_at: string;
}
/**
 *
 * @export
 * @interface MemberUpdateAsParent
 */
export interface MemberUpdateAsParent {
	/**
	 *
	 * @type {string}
	 * @memberof MemberUpdateAsParent
	 */
	user_id: string;
	/**
	 *
	 * @type {boolean}
	 * @memberof MemberUpdateAsParent
	 */
	is_parent: boolean;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
	/**
	 *
	 * @type {string}
	 * @memberof Message
	 */
	message: string;
}
/**
 *
 * @export
 * @interface ResponseSchemaCommunityPublic
 */
export interface ResponseSchemaCommunityPublic {
	/**
	 *
	 * @type {boolean}
	 * @memberof ResponseSchemaCommunityPublic
	 */
	success: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof ResponseSchemaCommunityPublic
	 */
	message: string;
	/**
	 *
	 * @type {CommunityPublic}
	 * @memberof ResponseSchemaCommunityPublic
	 */
	data?: CommunityPublic | null;
	/**
	 *
	 * @type {string}
	 * @memberof ResponseSchemaCommunityPublic
	 */
	error_code?: string | null;
}
/**
 *
 * @export
 * @interface ResponseSchemaListCommunityPublic
 */
export interface ResponseSchemaListCommunityPublic {
	/**
	 *
	 * @type {boolean}
	 * @memberof ResponseSchemaListCommunityPublic
	 */
	success: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof ResponseSchemaListCommunityPublic
	 */
	message: string;
	/**
	 *
	 * @type {Array<CommunityPublic>}
	 * @memberof ResponseSchemaListCommunityPublic
	 */
	data?: Array<CommunityPublic> | null;
	/**
	 *
	 * @type {string}
	 * @memberof ResponseSchemaListCommunityPublic
	 */
	error_code?: string | null;
}
/**
 *
 * @export
 * @interface ResponseSchemaListMember
 */
export interface ResponseSchemaListMember {
	/**
	 *
	 * @type {boolean}
	 * @memberof ResponseSchemaListMember
	 */
	success: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof ResponseSchemaListMember
	 */
	message: string;
	/**
	 *
	 * @type {Array<Member>}
	 * @memberof ResponseSchemaListMember
	 */
	data?: Array<Member> | null;
	/**
	 *
	 * @type {string}
	 * @memberof ResponseSchemaListMember
	 */
	error_code?: string | null;
}
/**
 *
 * @export
 * @interface ResponseSchemaSafezone
 */
export interface ResponseSchemaSafezone {
	/**
	 *
	 * @type {boolean}
	 * @memberof ResponseSchemaSafezone
	 */
	success: boolean;
	/**
	 *
	 * @type {string}
	 * @memberof ResponseSchemaSafezone
	 */
	message: string;
	/**
	 *
	 * @type {Safezone}
	 * @memberof ResponseSchemaSafezone
	 */
	data?: Safezone | null;
	/**
	 *
	 * @type {string}
	 * @memberof ResponseSchemaSafezone
	 */
	error_code?: string | null;
}
/**
 *
 * @export
 * @interface Safezone
 */
export interface Safezone {
	/**
	 *
	 * @type {string}
	 * @memberof Safezone
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Safezone
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Safezone
	 */
	updated_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Safezone
	 */
	name: string;
	/**
	 *
	 * @type {GeoPoint}
	 * @memberof Safezone
	 */
	center: GeoPoint;
	/**
	 *
	 * @type {number}
	 * @memberof Safezone
	 */
	radius: number;
	/**
	 *
	 * @type {string}
	 * @memberof Safezone
	 */
	description: string | null;
}
/**
 *
 * @export
 * @interface SafezoneCreate
 */
export interface SafezoneCreate {
	/**
	 *
	 * @type {string}
	 * @memberof SafezoneCreate
	 */
	community_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof SafezoneCreate
	 */
	name: string;
	/**
	 *
	 * @type {GeoPoint}
	 * @memberof SafezoneCreate
	 */
	center: GeoPoint;
	/**
	 *
	 * @type {number}
	 * @memberof SafezoneCreate
	 */
	radius: number;
	/**
	 *
	 * @type {string}
	 * @memberof SafezoneCreate
	 */
	description: string;
}
/**
 *
 * @export
 * @interface SafezonePublic
 */
export interface SafezonePublic {
	/**
	 *
	 * @type {string}
	 * @memberof SafezonePublic
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof SafezonePublic
	 */
	community_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof SafezonePublic
	 */
	name: string;
	/**
	 *
	 * @type {GeoPoint}
	 * @memberof SafezonePublic
	 */
	center: GeoPoint;
	/**
	 *
	 * @type {number}
	 * @memberof SafezonePublic
	 */
	radius: number;
	/**
	 *
	 * @type {string}
	 * @memberof SafezonePublic
	 */
	description: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SafezonePublic
	 */
	created_at: string;
	/**
	 *
	 * @type {string}
	 * @memberof SafezonePublic
	 */
	updated_at: string;
}
/**
 *
 * @export
 * @interface SafezoneUpdate
 */
export interface SafezoneUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof SafezoneUpdate
	 */
	name: string;
	/**
	 *
	 * @type {GeoPoint}
	 * @memberof SafezoneUpdate
	 */
	center: GeoPoint;
	/**
	 *
	 * @type {number}
	 * @memberof SafezoneUpdate
	 */
	radius: number;
	/**
	 *
	 * @type {string}
	 * @memberof SafezoneUpdate
	 */
	description: string;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
	/**
	 *
	 * @type {Array<ValidationErrorLocInner>}
	 * @memberof ValidationError
	 */
	loc: Array<ValidationErrorLocInner>;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	msg: string;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	type: string;
}
/**
 *
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {}

/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary Create Alert
		 * @param {AlertInput} alertInput
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		alertsCreateAlert: async (
			alertInput: AlertInput,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'alertInput' is not null or undefined
			assertParamExists("alertsCreateAlert", "alertInput", alertInput);
			const localVarPath = `/api/v1/alerts/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				alertInput,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Create Alert
		 * @param {AlertInput} alertInput
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async alertsCreateAlert(
			alertInput: AlertInput,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertOutput>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.alertsCreateAlert(
					alertInput,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AlertsApi.alertsCreateAlert"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = AlertsApiFp(configuration);
	return {
		/**
		 *
		 * @summary Create Alert
		 * @param {AlertInput} alertInput
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		alertsCreateAlert(
			alertInput: AlertInput,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AlertOutput> {
			return localVarFp
				.alertsCreateAlert(alertInput, accessToken, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
	/**
	 *
	 * @summary Create Alert
	 * @param {AlertInput} alertInput
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AlertsApi
	 */
	public alertsCreateAlert(
		alertInput: AlertInput,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return AlertsApiFp(this.configuration)
			.alertsCreateAlert(alertInput, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * CommunitiesApi - axios parameter creator
 * @export
 */
export const CommunitiesApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary Add Member
		 * @param {string} communityId
		 * @param {MemberAdd} memberAdd
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesAddMember: async (
			communityId: string,
			memberAdd: MemberAdd,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityId' is not null or undefined
			assertParamExists("communitiesAddMember", "communityId", communityId);
			// verify required parameter 'memberAdd' is not null or undefined
			assertParamExists("communitiesAddMember", "memberAdd", memberAdd);
			const localVarPath =
				`/api/v1/communities/{community_id}/add-member`.replace(
					`{${"community_id"}}`,
					encodeURIComponent(String(communityId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				memberAdd,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 맴버가 구성원 탈퇴
		 * @summary Cancel Confirm Member
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesCancelConfirmMember: async (
			communityId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityId' is not null or undefined
			assertParamExists(
				"communitiesCancelConfirmMember",
				"communityId",
				communityId,
			);
			const localVarPath = `/api/v1/communities/{community_id}/members`.replace(
				`{${"community_id"}}`,
				encodeURIComponent(String(communityId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Create Community
		 * @param {CommunityCreate} communityCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesCreateCommunity: async (
			communityCreate: CommunityCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityCreate' is not null or undefined
			assertParamExists(
				"communitiesCreateCommunity",
				"communityCreate",
				communityCreate,
			);
			const localVarPath = `/api/v1/communities/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				communityCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete Community
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesDeleteCommunity: async (
			communityId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityId' is not null or undefined
			assertParamExists(
				"communitiesDeleteCommunity",
				"communityId",
				communityId,
			);
			const localVarPath = `/api/v1/communities/{community_id}`.replace(
				`{${"community_id"}}`,
				encodeURIComponent(String(communityId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 커뮤니티 오너가 맴버 삭제
		 * @summary Delete Member By Owner
		 * @param {string} communityId
		 * @param {string} body
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesDeleteMemberByOwner: async (
			communityId: string,
			body: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityId' is not null or undefined
			assertParamExists(
				"communitiesDeleteMemberByOwner",
				"communityId",
				communityId,
			);
			// verify required parameter 'body' is not null or undefined
			assertParamExists("communitiesDeleteMemberByOwner", "body", body);
			const localVarPath = `/api/v1/communities/{community_id}/members`.replace(
				`{${"community_id"}}`,
				encodeURIComponent(String(communityId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				body,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Read Communities
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesReadCommunities: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/communities/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 커뮤니티 오너가 커뮤니티 특정 정보 조회
		 * @summary Read Community
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesReadCommunity: async (
			communityId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityId' is not null or undefined
			assertParamExists("communitiesReadCommunity", "communityId", communityId);
			const localVarPath = `/api/v1/communities/{community_id}`.replace(
				`{${"community_id"}}`,
				encodeURIComponent(String(communityId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Read Member
		 * @param {string} communityId
		 * @param {string} memberId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesReadMember: async (
			communityId: string,
			memberId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityId' is not null or undefined
			assertParamExists("communitiesReadMember", "communityId", communityId);
			// verify required parameter 'memberId' is not null or undefined
			assertParamExists("communitiesReadMember", "memberId", memberId);
			const localVarPath =
				`/api/v1/communities/{community_id}/members/{member_id}`
					.replace(
						`{${"community_id"}}`,
						encodeURIComponent(String(communityId)),
					)
					.replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Read Members
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesReadMembers: async (
			communityId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityId' is not null or undefined
			assertParamExists("communitiesReadMembers", "communityId", communityId);
			const localVarPath = `/api/v1/communities/{community_id}/members`.replace(
				`{${"community_id"}}`,
				encodeURIComponent(String(communityId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 커뮤니티 오너가 커뮤니티 기초정보 수정
		 * @summary Update Community
		 * @param {string} communityId
		 * @param {CommunityUpdate} communityUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesUpdateCommunity: async (
			communityId: string,
			communityUpdate: CommunityUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityId' is not null or undefined
			assertParamExists(
				"communitiesUpdateCommunity",
				"communityId",
				communityId,
			);
			// verify required parameter 'communityUpdate' is not null or undefined
			assertParamExists(
				"communitiesUpdateCommunity",
				"communityUpdate",
				communityUpdate,
			);
			const localVarPath = `/api/v1/communities/{community_id}`.replace(
				`{${"community_id"}}`,
				encodeURIComponent(String(communityId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				communityUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 커뮤니티 오너가 맴버의 부모여부를 수정
		 * @summary Update Member As Parent
		 * @param {string} communityId
		 * @param {MemberUpdateAsParent} memberUpdateAsParent
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesUpdateMemberAsParent: async (
			communityId: string,
			memberUpdateAsParent: MemberUpdateAsParent,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'communityId' is not null or undefined
			assertParamExists(
				"communitiesUpdateMemberAsParent",
				"communityId",
				communityId,
			);
			// verify required parameter 'memberUpdateAsParent' is not null or undefined
			assertParamExists(
				"communitiesUpdateMemberAsParent",
				"memberUpdateAsParent",
				memberUpdateAsParent,
			);
			const localVarPath = `/api/v1/communities/{community_id}/members`.replace(
				`{${"community_id"}}`,
				encodeURIComponent(String(communityId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				memberUpdateAsParent,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * CommunitiesApi - functional programming interface
 * @export
 */
export const CommunitiesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		CommunitiesApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Add Member
		 * @param {string} communityId
		 * @param {MemberAdd} memberAdd
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesAddMember(
			communityId: string,
			memberAdd: MemberAdd,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesAddMember(
					communityId,
					memberAdd,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesAddMember"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 맴버가 구성원 탈퇴
		 * @summary Cancel Confirm Member
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesCancelConfirmMember(
			communityId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesCancelConfirmMember(
					communityId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesCancelConfirmMember"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Create Community
		 * @param {CommunityCreate} communityCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesCreateCommunity(
			communityCreate: CommunityCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesCreateCommunity(
					communityCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesCreateCommunity"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Delete Community
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesDeleteCommunity(
			communityId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesDeleteCommunity(
					communityId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesDeleteCommunity"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 커뮤니티 오너가 맴버 삭제
		 * @summary Delete Member By Owner
		 * @param {string} communityId
		 * @param {string} body
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesDeleteMemberByOwner(
			communityId: string,
			body: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesDeleteMemberByOwner(
					communityId,
					body,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesDeleteMemberByOwner"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Read Communities
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesReadCommunities(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<ResponseSchemaListCommunityPublic>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesReadCommunities(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesReadCommunities"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 커뮤니티 오너가 커뮤니티 특정 정보 조회
		 * @summary Read Community
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesReadCommunity(
			communityId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<ResponseSchemaCommunityPublic>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesReadCommunity(
					communityId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesReadCommunity"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Read Member
		 * @param {string} communityId
		 * @param {string} memberId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesReadMember(
			communityId: string,
			memberId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesReadMember(
					communityId,
					memberId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesReadMember"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Read Members
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesReadMembers(
			communityId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<ResponseSchemaListMember>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesReadMembers(
					communityId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesReadMembers"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 커뮤니티 오너가 커뮤니티 기초정보 수정
		 * @summary Update Community
		 * @param {string} communityId
		 * @param {CommunityUpdate} communityUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesUpdateCommunity(
			communityId: string,
			communityUpdate: CommunityUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesUpdateCommunity(
					communityId,
					communityUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesUpdateCommunity"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 커뮤니티 오너가 맴버의 부모여부를 수정
		 * @summary Update Member As Parent
		 * @param {string} communityId
		 * @param {MemberUpdateAsParent} memberUpdateAsParent
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async communitiesUpdateMemberAsParent(
			communityId: string,
			memberUpdateAsParent: MemberUpdateAsParent,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.communitiesUpdateMemberAsParent(
					communityId,
					memberUpdateAsParent,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CommunitiesApi.communitiesUpdateMemberAsParent"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * CommunitiesApi - factory interface
 * @export
 */
export const CommunitiesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = CommunitiesApiFp(configuration);
	return {
		/**
		 *
		 * @summary Add Member
		 * @param {string} communityId
		 * @param {MemberAdd} memberAdd
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesAddMember(
			communityId: string,
			memberAdd: MemberAdd,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.communitiesAddMember(communityId, memberAdd, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 맴버가 구성원 탈퇴
		 * @summary Cancel Confirm Member
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesCancelConfirmMember(
			communityId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.communitiesCancelConfirmMember(communityId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Create Community
		 * @param {CommunityCreate} communityCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesCreateCommunity(
			communityCreate: CommunityCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.communitiesCreateCommunity(communityCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete Community
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesDeleteCommunity(
			communityId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.communitiesDeleteCommunity(communityId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 커뮤니티 오너가 맴버 삭제
		 * @summary Delete Member By Owner
		 * @param {string} communityId
		 * @param {string} body
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesDeleteMemberByOwner(
			communityId: string,
			body: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.communitiesDeleteMemberByOwner(communityId, body, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Read Communities
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesReadCommunities(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ResponseSchemaListCommunityPublic> {
			return localVarFp
				.communitiesReadCommunities(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 커뮤니티 오너가 커뮤니티 특정 정보 조회
		 * @summary Read Community
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesReadCommunity(
			communityId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ResponseSchemaCommunityPublic> {
			return localVarFp
				.communitiesReadCommunity(communityId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Read Member
		 * @param {string} communityId
		 * @param {string} memberId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesReadMember(
			communityId: string,
			memberId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Member> {
			return localVarFp
				.communitiesReadMember(communityId, memberId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Read Members
		 * @param {string} communityId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesReadMembers(
			communityId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ResponseSchemaListMember> {
			return localVarFp
				.communitiesReadMembers(communityId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 커뮤니티 오너가 커뮤니티 기초정보 수정
		 * @summary Update Community
		 * @param {string} communityId
		 * @param {CommunityUpdate} communityUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesUpdateCommunity(
			communityId: string,
			communityUpdate: CommunityUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.communitiesUpdateCommunity(
					communityId,
					communityUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 커뮤니티 오너가 맴버의 부모여부를 수정
		 * @summary Update Member As Parent
		 * @param {string} communityId
		 * @param {MemberUpdateAsParent} memberUpdateAsParent
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		communitiesUpdateMemberAsParent(
			communityId: string,
			memberUpdateAsParent: MemberUpdateAsParent,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.communitiesUpdateMemberAsParent(
					communityId,
					memberUpdateAsParent,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * CommunitiesApi - object-oriented interface
 * @export
 * @class CommunitiesApi
 * @extends {BaseAPI}
 */
export class CommunitiesApi extends BaseAPI {
	/**
	 *
	 * @summary Add Member
	 * @param {string} communityId
	 * @param {MemberAdd} memberAdd
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesAddMember(
		communityId: string,
		memberAdd: MemberAdd,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesAddMember(communityId, memberAdd, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 맴버가 구성원 탈퇴
	 * @summary Cancel Confirm Member
	 * @param {string} communityId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesCancelConfirmMember(
		communityId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesCancelConfirmMember(communityId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Create Community
	 * @param {CommunityCreate} communityCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesCreateCommunity(
		communityCreate: CommunityCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesCreateCommunity(communityCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete Community
	 * @param {string} communityId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesDeleteCommunity(
		communityId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesDeleteCommunity(communityId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 커뮤니티 오너가 맴버 삭제
	 * @summary Delete Member By Owner
	 * @param {string} communityId
	 * @param {string} body
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesDeleteMemberByOwner(
		communityId: string,
		body: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesDeleteMemberByOwner(communityId, body, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Read Communities
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesReadCommunities(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesReadCommunities(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 커뮤니티 오너가 커뮤니티 특정 정보 조회
	 * @summary Read Community
	 * @param {string} communityId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesReadCommunity(
		communityId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesReadCommunity(communityId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Read Member
	 * @param {string} communityId
	 * @param {string} memberId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesReadMember(
		communityId: string,
		memberId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesReadMember(communityId, memberId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Read Members
	 * @param {string} communityId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesReadMembers(
		communityId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesReadMembers(communityId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 커뮤니티 오너가 커뮤니티 기초정보 수정
	 * @summary Update Community
	 * @param {string} communityId
	 * @param {CommunityUpdate} communityUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesUpdateCommunity(
		communityId: string,
		communityUpdate: CommunityUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesUpdateCommunity(
				communityId,
				communityUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 커뮤니티 오너가 맴버의 부모여부를 수정
	 * @summary Update Member As Parent
	 * @param {string} communityId
	 * @param {MemberUpdateAsParent} memberUpdateAsParent
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CommunitiesApi
	 */
	public communitiesUpdateMemberAsParent(
		communityId: string,
		memberUpdateAsParent: MemberUpdateAsParent,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CommunitiesApiFp(this.configuration)
			.communitiesUpdateMemberAsParent(
				communityId,
				memberUpdateAsParent,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * LocationsApi - axios parameter creator
 * @export
 */
export const LocationsApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary Delete Location Log
		 * @param {string} locationId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsDeleteLocationLog: async (
			locationId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'locationId' is not null or undefined
			assertParamExists("locationsDeleteLocationLog", "locationId", locationId);
			const localVarPath = `/api/v1/locations/{location_id}`.replace(
				`{${"location_id"}}`,
				encodeURIComponent(String(locationId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Read Location Log
		 * @param {string} locationId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsReadLocationLog: async (
			locationId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'locationId' is not null or undefined
			assertParamExists("locationsReadLocationLog", "locationId", locationId);
			const localVarPath = `/api/v1/locations/{location_id}`.replace(
				`{${"location_id"}}`,
				encodeURIComponent(String(locationId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Read Location Logs
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsReadLocationLogs: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/locations/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update Location
		 * @param {LocationUpdate} locationUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsUpdateLocation: async (
			locationUpdate: LocationUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'locationUpdate' is not null or undefined
			assertParamExists(
				"locationsUpdateLocation",
				"locationUpdate",
				locationUpdate,
			);
			const localVarPath = `/api/v1/locations/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				locationUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		LocationsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Delete Location Log
		 * @param {string} locationId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async locationsDeleteLocationLog(
			locationId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.locationsDeleteLocationLog(
					locationId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["LocationsApi.locationsDeleteLocationLog"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Read Location Log
		 * @param {string} locationId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async locationsReadLocationLog(
			locationId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationLog>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.locationsReadLocationLog(
					locationId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["LocationsApi.locationsReadLocationLog"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Read Location Logs
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async locationsReadLocationLogs(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocationLog>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.locationsReadLocationLogs(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["LocationsApi.locationsReadLocationLogs"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Update Location
		 * @param {LocationUpdate} locationUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async locationsUpdateLocation(
			locationUpdate: LocationUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.locationsUpdateLocation(
					locationUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["LocationsApi.locationsUpdateLocation"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = LocationsApiFp(configuration);
	return {
		/**
		 *
		 * @summary Delete Location Log
		 * @param {string} locationId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsDeleteLocationLog(
			locationId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.locationsDeleteLocationLog(locationId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Read Location Log
		 * @param {string} locationId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsReadLocationLog(
			locationId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<LocationLog> {
			return localVarFp
				.locationsReadLocationLog(locationId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Read Location Logs
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsReadLocationLogs(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<LocationLog> {
			return localVarFp
				.locationsReadLocationLogs(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update Location
		 * @param {LocationUpdate} locationUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		locationsUpdateLocation(
			locationUpdate: LocationUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.locationsUpdateLocation(locationUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI {
	/**
	 *
	 * @summary Delete Location Log
	 * @param {string} locationId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public locationsDeleteLocationLog(
		locationId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return LocationsApiFp(this.configuration)
			.locationsDeleteLocationLog(locationId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Read Location Log
	 * @param {string} locationId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public locationsReadLocationLog(
		locationId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return LocationsApiFp(this.configuration)
			.locationsReadLocationLog(locationId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Read Location Logs
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public locationsReadLocationLogs(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return LocationsApiFp(this.configuration)
			.locationsReadLocationLogs(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update Location
	 * @param {LocationUpdate} locationUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public locationsUpdateLocation(
		locationUpdate: LocationUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return LocationsApiFp(this.configuration)
			.locationsUpdateLocation(locationUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * SafezonesApi - axios parameter creator
 * @export
 */
export const SafezonesApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary Create Safezone
		 * @param {SafezoneCreate} safezoneCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesCreateSafezone: async (
			safezoneCreate: SafezoneCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'safezoneCreate' is not null or undefined
			assertParamExists(
				"safezonesCreateSafezone",
				"safezoneCreate",
				safezoneCreate,
			);
			const localVarPath = `/api/v1/safezones/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				safezoneCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete Safezone
		 * @param {string} safezoneId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesDeleteSafezone: async (
			safezoneId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'safezoneId' is not null or undefined
			assertParamExists("safezonesDeleteSafezone", "safezoneId", safezoneId);
			const localVarPath = `/api/v1/safezones/{safezone_id}`.replace(
				`{${"safezone_id"}}`,
				encodeURIComponent(String(safezoneId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Read Safezone
		 * @param {string} safezoneId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesReadSafezone: async (
			safezoneId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'safezoneId' is not null or undefined
			assertParamExists("safezonesReadSafezone", "safezoneId", safezoneId);
			const localVarPath = `/api/v1/safezones/{safezone_id}`.replace(
				`{${"safezone_id"}}`,
				encodeURIComponent(String(safezoneId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Read Safezones
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesReadSafezones: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/safezones/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update Safezone
		 * @param {string} safezoneId
		 * @param {SafezoneUpdate} safezoneUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesUpdateSafezone: async (
			safezoneId: string,
			safezoneUpdate: SafezoneUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'safezoneId' is not null or undefined
			assertParamExists("safezonesUpdateSafezone", "safezoneId", safezoneId);
			// verify required parameter 'safezoneUpdate' is not null or undefined
			assertParamExists(
				"safezonesUpdateSafezone",
				"safezoneUpdate",
				safezoneUpdate,
			);
			const localVarPath = `/api/v1/safezones/{safezone_id}`.replace(
				`{${"safezone_id"}}`,
				encodeURIComponent(String(safezoneId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				safezoneUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * SafezonesApi - functional programming interface
 * @export
 */
export const SafezonesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SafezonesApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Create Safezone
		 * @param {SafezoneCreate} safezoneCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async safezonesCreateSafezone(
			safezoneCreate: SafezoneCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.safezonesCreateSafezone(
					safezoneCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["SafezonesApi.safezonesCreateSafezone"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Delete Safezone
		 * @param {string} safezoneId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async safezonesDeleteSafezone(
			safezoneId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.safezonesDeleteSafezone(
					safezoneId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["SafezonesApi.safezonesDeleteSafezone"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Read Safezone
		 * @param {string} safezoneId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async safezonesReadSafezone(
			safezoneId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Safezone>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.safezonesReadSafezone(
					safezoneId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["SafezonesApi.safezonesReadSafezone"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Read Safezones
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async safezonesReadSafezones(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<ResponseSchemaSafezone>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.safezonesReadSafezones(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["SafezonesApi.safezonesReadSafezones"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Update Safezone
		 * @param {string} safezoneId
		 * @param {SafezoneUpdate} safezoneUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async safezonesUpdateSafezone(
			safezoneId: string,
			safezoneUpdate: SafezoneUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.safezonesUpdateSafezone(
					safezoneId,
					safezoneUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["SafezonesApi.safezonesUpdateSafezone"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * SafezonesApi - factory interface
 * @export
 */
export const SafezonesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = SafezonesApiFp(configuration);
	return {
		/**
		 *
		 * @summary Create Safezone
		 * @param {SafezoneCreate} safezoneCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesCreateSafezone(
			safezoneCreate: SafezoneCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.safezonesCreateSafezone(safezoneCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete Safezone
		 * @param {string} safezoneId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesDeleteSafezone(
			safezoneId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.safezonesDeleteSafezone(safezoneId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Read Safezone
		 * @param {string} safezoneId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesReadSafezone(
			safezoneId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Safezone> {
			return localVarFp
				.safezonesReadSafezone(safezoneId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Read Safezones
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesReadSafezones(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ResponseSchemaSafezone> {
			return localVarFp
				.safezonesReadSafezones(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update Safezone
		 * @param {string} safezoneId
		 * @param {SafezoneUpdate} safezoneUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		safezonesUpdateSafezone(
			safezoneId: string,
			safezoneUpdate: SafezoneUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.safezonesUpdateSafezone(
					safezoneId,
					safezoneUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * SafezonesApi - object-oriented interface
 * @export
 * @class SafezonesApi
 * @extends {BaseAPI}
 */
export class SafezonesApi extends BaseAPI {
	/**
	 *
	 * @summary Create Safezone
	 * @param {SafezoneCreate} safezoneCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SafezonesApi
	 */
	public safezonesCreateSafezone(
		safezoneCreate: SafezoneCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return SafezonesApiFp(this.configuration)
			.safezonesCreateSafezone(safezoneCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete Safezone
	 * @param {string} safezoneId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SafezonesApi
	 */
	public safezonesDeleteSafezone(
		safezoneId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return SafezonesApiFp(this.configuration)
			.safezonesDeleteSafezone(safezoneId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Read Safezone
	 * @param {string} safezoneId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SafezonesApi
	 */
	public safezonesReadSafezone(
		safezoneId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return SafezonesApiFp(this.configuration)
			.safezonesReadSafezone(safezoneId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Read Safezones
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SafezonesApi
	 */
	public safezonesReadSafezones(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return SafezonesApiFp(this.configuration)
			.safezonesReadSafezones(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update Safezone
	 * @param {string} safezoneId
	 * @param {SafezoneUpdate} safezoneUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SafezonesApi
	 */
	public safezonesUpdateSafezone(
		safezoneId: string,
		safezoneUpdate: SafezoneUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return SafezonesApiFp(this.configuration)
			.safezonesUpdateSafezone(safezoneId, safezoneUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
