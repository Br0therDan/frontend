/* tslint:disable */
/* eslint-disable */
/**
 * MySingle Commerce  [dev]
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
	BASE_PATH,
	COLLECTION_FORMATS,
	BaseAPI,
	RequiredError,
	operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface Brand
 */
export interface Brand {
	/**
	 *
	 * @type {string}
	 * @memberof Brand
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Brand
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Brand
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Brand
	 */
	logo_url?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Brand
	 */
	app_name: string;
}
/**
 *
 * @export
 * @interface Brand1
 */
export interface Brand1 {
	/**
	 *
	 * @type {string}
	 * @memberof Brand1
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof Brand1
	 */
	collection: string;
}
/**
 *
 * @export
 * @interface BrandCreate
 */
export interface BrandCreate {
	/**
	 *
	 * @type {string}
	 * @memberof BrandCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof BrandCreate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof BrandCreate
	 */
	logo_url?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof BrandCreate
	 */
	app_name: string;
}
/**
 *
 * @export
 * @interface BrandUpdate
 */
export interface BrandUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof BrandUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof BrandUpdate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof BrandUpdate
	 */
	logo_url?: string | null;
}
/**
 * 카테고리 정보 (트리 구조를 위해 parent를 자기참조 가능) created_at/updated_at이 불필요하다고 가정
 * @export
 * @interface Category
 */
export interface Category {
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	description?: string | null;
	/**
	 *
	 * @type {ParentId}
	 * @memberof Category
	 */
	parent_id?: ParentId | null;
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	app_name: string;
}
/**
 *
 * @export
 * @interface Category1
 */
export interface Category1 {
	/**
	 *
	 * @type {string}
	 * @memberof Category1
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof Category1
	 */
	collection: string;
}
/**
 *
 * @export
 * @interface CategoryCreate
 */
export interface CategoryCreate {
	/**
	 *
	 * @type {string}
	 * @memberof CategoryCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryCreate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryCreate
	 */
	parent_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryCreate
	 */
	app_name: string;
}
/**
 *
 * @export
 * @interface CategoryUpdate
 */
export interface CategoryUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof CategoryUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryUpdate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryUpdate
	 */
	parent_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryUpdate
	 */
	app_name?: string | null;
}
/**
 *
 * @export
 * @interface ChannelId
 */
export interface ChannelId {
	/**
	 *
	 * @type {string}
	 * @memberof ChannelId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelId
	 */
	collection: string;
}
/**
 * 특정 채널에 등록된 상품옵션. 채널별 가격, SKU, 상태 등
 * @export
 * @interface ChannelListing
 */
export interface ChannelListing {
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	updated_at?: string;
	/**
	 *
	 * @type {ChannelId}
	 * @memberof ChannelListing
	 */
	channel_id: ChannelId;
	/**
	 *
	 * @type {VariantId}
	 * @memberof ChannelListing
	 */
	variant_id: VariantId;
	/**
	 *
	 * @type {number}
	 * @memberof ChannelListing
	 */
	channel_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	external_sku?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface ChannelListingCreate
 */
export interface ChannelListingCreate {
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingCreate
	 */
	channel_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingCreate
	 */
	variant_id: string;
	/**
	 *
	 * @type {number}
	 * @memberof ChannelListingCreate
	 */
	channel_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingCreate
	 */
	external_sku?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingCreate
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface ChannelListingUpdate
 */
export interface ChannelListingUpdate {
	/**
	 *
	 * @type {number}
	 * @memberof ChannelListingUpdate
	 */
	channel_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingUpdate
	 */
	external_sku?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingUpdate
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
	/**
	 *
	 * @type {Array<ValidationError>}
	 * @memberof HTTPValidationError
	 */
	detail?: Array<ValidationError>;
}
/**
 * 단일 옵션(Variant)의 재고 정보를 관리
 * @export
 * @interface Inventory
 */
export interface Inventory {
	/**
	 *
	 * @type {string}
	 * @memberof Inventory
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Inventory
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Inventory
	 */
	updated_at?: string;
	/**
	 *
	 * @type {VariantId}
	 * @memberof Inventory
	 */
	variant_id: VariantId;
	/**
	 *
	 * @type {number}
	 * @memberof Inventory
	 */
	stock?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Inventory
	 */
	average_cost?: number | null;
}
/**
 *
 * @export
 * @interface InventoryCreate
 */
export interface InventoryCreate {
	/**
	 *
	 * @type {string}
	 * @memberof InventoryCreate
	 */
	variant_id: string;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryCreate
	 */
	stock?: number;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryCreate
	 */
	average_cost?: number | null;
}
/**
 *
 * @export
 * @interface InventoryId
 */
export interface InventoryId {
	/**
	 *
	 * @type {string}
	 * @memberof InventoryId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryId
	 */
	collection: string;
}
/**
 * 재고 변동 이력 (입고, 출고, 반품 등)
 * @export
 * @interface InventoryTransaction
 */
export interface InventoryTransaction {
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	updated_at?: string;
	/**
	 *
	 * @type {InventoryId}
	 * @memberof InventoryTransaction
	 */
	inventory_id: InventoryId;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryTransaction
	 */
	quantity_change: number;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	reason?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryTransaction
	 */
	cost_per_unit?: number | null;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	transaction_at?: string;
}
/**
 *
 * @export
 * @interface InventoryTransactionRequest
 */
export interface InventoryTransactionRequest {
	/**
	 *
	 * @type {number}
	 * @memberof InventoryTransactionRequest
	 */
	quantity_change: number;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransactionRequest
	 */
	reason?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryTransactionRequest
	 */
	cost_per_unit?: number | null;
}
/**
 *
 * @export
 * @interface InventoryUpdate
 */
export interface InventoryUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof InventoryUpdate
	 */
	variant_id?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryUpdate
	 */
	stock?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryUpdate
	 */
	average_cost?: number | null;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
	/**
	 *
	 * @type {string}
	 * @memberof Message
	 */
	message: string;
}
/**
 * 여러 채널에서 들어온 주문을 통합 관리
 * @export
 * @interface Order
 */
export interface Order {
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	_id?: string | null;
	/**
	 *
	 * @type {ChannelId}
	 * @memberof Order
	 */
	channel_id: ChannelId;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	external_order_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	order_date?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	order_status?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	customer_id?: string | null;
}
/**
 *
 * @export
 * @interface OrderCreate
 */
export interface OrderCreate {
	/**
	 *
	 * @type {string}
	 * @memberof OrderCreate
	 */
	channel_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderCreate
	 */
	external_order_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderCreate
	 */
	order_status?: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderCreate
	 */
	customer_id: string;
}
/**
 *
 * @export
 * @interface OrderId
 */
export interface OrderId {
	/**
	 *
	 * @type {string}
	 * @memberof OrderId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderId
	 */
	collection: string;
}
/**
 * 주문 상세항목 (하나의 주문에 여러 상품옵션 가능)
 * @export
 * @interface OrderLineItem
 */
export interface OrderLineItem {
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItem
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItem
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItem
	 */
	updated_at?: string;
	/**
	 *
	 * @type {OrderId}
	 * @memberof OrderLineItem
	 */
	order_id: OrderId;
	/**
	 *
	 * @type {VariantId}
	 * @memberof OrderLineItem
	 */
	variant_id: VariantId;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItem
	 */
	quantity: number;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItem
	 */
	unit_price: number;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItem
	 */
	total_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItem
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface OrderLineItemCreate
 */
export interface OrderLineItemCreate {
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemCreate
	 */
	order_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemCreate
	 */
	variant_id: string;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemCreate
	 */
	quantity: number;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemCreate
	 */
	unit_price: number;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemCreate
	 */
	total_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemCreate
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface OrderLineItemUpdate
 */
export interface OrderLineItemUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemUpdate
	 */
	order_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemUpdate
	 */
	variant_id?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemUpdate
	 */
	quantity?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemUpdate
	 */
	unit_price?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemUpdate
	 */
	total_price?: number | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemUpdate
	 */
	status?: string | null;
}
/**
 *
 * @export
 * @interface OrderUpdate
 */
export interface OrderUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof OrderUpdate
	 */
	channel_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderUpdate
	 */
	external_order_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderUpdate
	 */
	order_status?: string | null;
}
/**
 *
 * @export
 * @interface ParentId
 */
export interface ParentId {
	/**
	 *
	 * @type {string}
	 * @memberof ParentId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ParentId
	 */
	collection: string;
}
/**
 *
 * @export
 * @interface ParentIdAnyOf
 */
export interface ParentIdAnyOf {
	/**
	 *
	 * @type {string}
	 * @memberof ParentIdAnyOf
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ParentIdAnyOf
	 */
	collection: string;
}
/**
 * 상품 상위 정보 (타임스탬프 추적)
 * @export
 * @interface Product
 */
export interface Product {
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	updated_at?: string;
	/**
	 *
	 * @type {Brand1}
	 * @memberof Product
	 */
	brand?: Brand1 | null;
	/**
	 *
	 * @type {Category1}
	 * @memberof Product
	 */
	category?: Category1 | null;
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	description?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof Product
	 */
	base_price?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof Product
	 */
	is_active?: boolean;
	/**
	 *
	 * @type {Array<ProductVariantsInner>}
	 * @memberof Product
	 */
	variants?: Array<ProductVariantsInner>;
}
/**
 *
 * @export
 * @interface ProductCreate
 */
export interface ProductCreate {
	/**
	 *
	 * @type {string}
	 * @memberof ProductCreate
	 */
	brand_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductCreate
	 */
	category_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductCreate
	 */
	description?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductCreate
	 */
	base_price?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductCreate
	 */
	is_active?: boolean;
}
/**
 *
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof ProductUpdate
	 */
	brand_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductUpdate
	 */
	category_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductUpdate
	 */
	description?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductUpdate
	 */
	base_price?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductUpdate
	 */
	is_active: boolean | null;
}
/**
 * 상품 옵션(색상, 사이즈, SKU 등)
 * @export
 * @interface ProductVariant
 */
export interface ProductVariant {
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	updated_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	product_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	sku?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariant
	 */
	option_price?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariant
	 */
	option_cost?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductVariant
	 */
	is_active?: boolean;
}
/**
 *
 * @export
 * @interface ProductVariantCreate
 */
export interface ProductVariantCreate {
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantCreate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantCreate
	 */
	sku?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariantCreate
	 */
	option_price?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariantCreate
	 */
	option_cost?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductVariantCreate
	 */
	is_active?: boolean;
}
/**
 *
 * @export
 * @interface ProductVariantUpdate
 */
export interface ProductVariantUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantUpdate
	 */
	sku?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariantUpdate
	 */
	option_price?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariantUpdate
	 */
	option_cost?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductVariantUpdate
	 */
	is_active?: boolean | null;
}
/**
 *
 * @export
 * @interface ProductVariantsInner
 */
export interface ProductVariantsInner {
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantsInner
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantsInner
	 */
	collection: string;
}
/**
 * 예) 자사몰, 쿠팡, Qoo10 등
 * @export
 * @interface SalesChannel
 */
export interface SalesChannel {
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannel
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannel
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannel
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannel
	 */
	channel_code?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannel
	 */
	app_name: string;
}
/**
 *
 * @export
 * @interface SalesChannelCreate
 */
export interface SalesChannelCreate {
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelCreate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelCreate
	 */
	channel_code?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelCreate
	 */
	app_name: string;
}
/**
 *
 * @export
 * @interface SalesChannelUpdate
 */
export interface SalesChannelUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelUpdate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelUpdate
	 */
	channel_code?: string | null;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
	/**
	 *
	 * @type {Array<ValidationErrorLocInner>}
	 * @memberof ValidationError
	 */
	loc: Array<ValidationErrorLocInner>;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	msg: string;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	type: string;
}
/**
 *
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {}
/**
 *
 * @export
 * @interface VariantId
 */
export interface VariantId {
	/**
	 *
	 * @type {string}
	 * @memberof VariantId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof VariantId
	 */
	collection: string;
}

/**
 * BrandApi - axios parameter creator
 * @export
 */
export const BrandApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 브랜드 생성 - 사용자가 소유한 브랜드 중 동일한 이름이 있는지 검사
		 * @summary Create Brand
		 * @param {BrandCreate} brandCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandCreateBrand: async (
			brandCreate: BrandCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'brandCreate' is not null or undefined
			assertParamExists("brandCreateBrand", "brandCreate", brandCreate);
			const localVarPath = `/api/v1/brands/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				brandCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 브랜드 삭제
		 * @summary Delete Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandDeleteBrand: async (
			brandId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'brandId' is not null or undefined
			assertParamExists("brandDeleteBrand", "brandId", brandId);
			const localVarPath = `/api/v1/brands/{brand_id}`.replace(
				`{${"brand_id"}}`,
				encodeURIComponent(String(brandId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 브랜드 상세 조회
		 * @summary Read Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandReadBrand: async (
			brandId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'brandId' is not null or undefined
			assertParamExists("brandReadBrand", "brandId", brandId);
			const localVarPath = `/api/v1/brands/{brand_id}`.replace(
				`{${"brand_id"}}`,
				encodeURIComponent(String(brandId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 브랜드 목록 조회
		 * @summary Read Brands
		 * @param {string | null} [appName]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandReadBrands: async (
			appName?: string | null,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/brands/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			if (appName !== undefined) {
				localVarQueryParameter["app_name"] = appName;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 브랜드 수정
		 * @summary Update Brand
		 * @param {string} brandId
		 * @param {BrandUpdate} brandUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandUpdateBrand: async (
			brandId: string,
			brandUpdate: BrandUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'brandId' is not null or undefined
			assertParamExists("brandUpdateBrand", "brandId", brandId);
			// verify required parameter 'brandUpdate' is not null or undefined
			assertParamExists("brandUpdateBrand", "brandUpdate", brandUpdate);
			const localVarPath = `/api/v1/brands/{brand_id}`.replace(
				`{${"brand_id"}}`,
				encodeURIComponent(String(brandId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				brandUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * BrandApi - functional programming interface
 * @export
 */
export const BrandApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = BrandApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 브랜드 생성 - 사용자가 소유한 브랜드 중 동일한 이름이 있는지 검사
		 * @summary Create Brand
		 * @param {BrandCreate} brandCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async brandCreateBrand(
			brandCreate: BrandCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brand>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.brandCreateBrand(
					brandCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BrandApi.brandCreateBrand"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 브랜드 삭제
		 * @summary Delete Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async brandDeleteBrand(
			brandId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.brandDeleteBrand(
					brandId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BrandApi.brandDeleteBrand"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 브랜드 상세 조회
		 * @summary Read Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async brandReadBrand(
			brandId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brand>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.brandReadBrand(
				brandId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BrandApi.brandReadBrand"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 브랜드 목록 조회
		 * @summary Read Brands
		 * @param {string | null} [appName]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async brandReadBrands(
			appName?: string | null,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Brand>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.brandReadBrands(
				appName,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BrandApi.brandReadBrands"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 브랜드 수정
		 * @summary Update Brand
		 * @param {string} brandId
		 * @param {BrandUpdate} brandUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async brandUpdateBrand(
			brandId: string,
			brandUpdate: BrandUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brand>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.brandUpdateBrand(
					brandId,
					brandUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BrandApi.brandUpdateBrand"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * BrandApi - factory interface
 * @export
 */
export const BrandApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = BrandApiFp(configuration);
	return {
		/**
		 * 신규 브랜드 생성 - 사용자가 소유한 브랜드 중 동일한 이름이 있는지 검사
		 * @summary Create Brand
		 * @param {BrandCreate} brandCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandCreateBrand(
			brandCreate: BrandCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Brand> {
			return localVarFp
				.brandCreateBrand(brandCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 브랜드 삭제
		 * @summary Delete Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandDeleteBrand(
			brandId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.brandDeleteBrand(brandId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 브랜드 상세 조회
		 * @summary Read Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandReadBrand(
			brandId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Brand> {
			return localVarFp
				.brandReadBrand(brandId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 브랜드 목록 조회
		 * @summary Read Brands
		 * @param {string | null} [appName]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandReadBrands(
			appName?: string | null,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Brand>> {
			return localVarFp
				.brandReadBrands(appName, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 브랜드 수정
		 * @summary Update Brand
		 * @param {string} brandId
		 * @param {BrandUpdate} brandUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		brandUpdateBrand(
			brandId: string,
			brandUpdate: BrandUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Brand> {
			return localVarFp
				.brandUpdateBrand(brandId, brandUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * BrandApi - object-oriented interface
 * @export
 * @class BrandApi
 * @extends {BaseAPI}
 */
export class BrandApi extends BaseAPI {
	/**
	 * 신규 브랜드 생성 - 사용자가 소유한 브랜드 중 동일한 이름이 있는지 검사
	 * @summary Create Brand
	 * @param {BrandCreate} brandCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BrandApi
	 */
	public brandCreateBrand(
		brandCreate: BrandCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BrandApiFp(this.configuration)
			.brandCreateBrand(brandCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 브랜드 삭제
	 * @summary Delete Brand
	 * @param {string} brandId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BrandApi
	 */
	public brandDeleteBrand(
		brandId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BrandApiFp(this.configuration)
			.brandDeleteBrand(brandId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 브랜드 상세 조회
	 * @summary Read Brand
	 * @param {string} brandId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BrandApi
	 */
	public brandReadBrand(
		brandId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BrandApiFp(this.configuration)
			.brandReadBrand(brandId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 브랜드 목록 조회
	 * @summary Read Brands
	 * @param {string | null} [appName]
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BrandApi
	 */
	public brandReadBrands(
		appName?: string | null,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BrandApiFp(this.configuration)
			.brandReadBrands(appName, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 브랜드 수정
	 * @summary Update Brand
	 * @param {string} brandId
	 * @param {BrandUpdate} brandUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BrandApi
	 */
	public brandUpdateBrand(
		brandId: string,
		brandUpdate: BrandUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BrandApiFp(this.configuration)
			.brandUpdateBrand(brandId, brandUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 카테고리 생성 - 사용자가 소유한 카테고리 중 동일한 이름이 있는지 검사 - 부모 카테고리(parent_id)가 있다면, 해당 카테고리가 존재하고 현재 사용자가 소유한 카테고리여야 함
		 * @summary Create Category
		 * @param {CategoryCreate} categoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryCreateCategory: async (
			categoryCreate: CategoryCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryCreate' is not null or undefined
			assertParamExists(
				"categoryCreateCategory",
				"categoryCreate",
				categoryCreate,
			);
			const localVarPath = `/api/v1/categories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				categoryCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 카테고리 삭제
		 * @summary Delete Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryDeleteCategory: async (
			categoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists("categoryDeleteCategory", "categoryId", categoryId);
			const localVarPath = `/api/v1/categories/{category_id}`.replace(
				`{${"category_id"}}`,
				encodeURIComponent(String(categoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 카테고리 목록 조회
		 * @summary Read Categories
		 * @param {string | null} [appName]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryReadCategories: async (
			appName?: string | null,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/categories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			if (appName !== undefined) {
				localVarQueryParameter["app_name"] = appName;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 카테고리 상세 조회
		 * @summary Read Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryReadCategory: async (
			categoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists("categoryReadCategory", "categoryId", categoryId);
			const localVarPath = `/api/v1/categories/{category_id}`.replace(
				`{${"category_id"}}`,
				encodeURIComponent(String(categoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 카테고리 수정
		 * @summary Update Category
		 * @param {string} categoryId
		 * @param {CategoryUpdate} categoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryUpdateCategory: async (
			categoryId: string,
			categoryUpdate: CategoryUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists("categoryUpdateCategory", "categoryId", categoryId);
			// verify required parameter 'categoryUpdate' is not null or undefined
			assertParamExists(
				"categoryUpdateCategory",
				"categoryUpdate",
				categoryUpdate,
			);
			const localVarPath = `/api/v1/categories/{category_id}`.replace(
				`{${"category_id"}}`,
				encodeURIComponent(String(categoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				categoryUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 카테고리 생성 - 사용자가 소유한 카테고리 중 동일한 이름이 있는지 검사 - 부모 카테고리(parent_id)가 있다면, 해당 카테고리가 존재하고 현재 사용자가 소유한 카테고리여야 함
		 * @summary Create Category
		 * @param {CategoryCreate} categoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async categoryCreateCategory(
			categoryCreate: CategoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.categoryCreateCategory(
					categoryCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CategoryApi.categoryCreateCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 카테고리 삭제
		 * @summary Delete Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async categoryDeleteCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.categoryDeleteCategory(
					categoryId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CategoryApi.categoryDeleteCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 카테고리 목록 조회
		 * @summary Read Categories
		 * @param {string | null} [appName]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async categoryReadCategories(
			appName?: string | null,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<Category>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.categoryReadCategories(
					appName,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CategoryApi.categoryReadCategories"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 카테고리 상세 조회
		 * @summary Read Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async categoryReadCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.categoryReadCategory(
					categoryId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CategoryApi.categoryReadCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 카테고리 수정
		 * @summary Update Category
		 * @param {string} categoryId
		 * @param {CategoryUpdate} categoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async categoryUpdateCategory(
			categoryId: string,
			categoryUpdate: CategoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.categoryUpdateCategory(
					categoryId,
					categoryUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["CategoryApi.categoryUpdateCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = CategoryApiFp(configuration);
	return {
		/**
		 * 신규 카테고리 생성 - 사용자가 소유한 카테고리 중 동일한 이름이 있는지 검사 - 부모 카테고리(parent_id)가 있다면, 해당 카테고리가 존재하고 현재 사용자가 소유한 카테고리여야 함
		 * @summary Create Category
		 * @param {CategoryCreate} categoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryCreateCategory(
			categoryCreate: CategoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Category> {
			return localVarFp
				.categoryCreateCategory(categoryCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 카테고리 삭제
		 * @summary Delete Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryDeleteCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.categoryDeleteCategory(categoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 카테고리 목록 조회
		 * @summary Read Categories
		 * @param {string | null} [appName]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryReadCategories(
			appName?: string | null,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Category>> {
			return localVarFp
				.categoryReadCategories(appName, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 카테고리 상세 조회
		 * @summary Read Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryReadCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Category> {
			return localVarFp
				.categoryReadCategory(categoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 카테고리 수정
		 * @summary Update Category
		 * @param {string} categoryId
		 * @param {CategoryUpdate} categoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		categoryUpdateCategory(
			categoryId: string,
			categoryUpdate: CategoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Category> {
			return localVarFp
				.categoryUpdateCategory(
					categoryId,
					categoryUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
	/**
	 * 신규 카테고리 생성 - 사용자가 소유한 카테고리 중 동일한 이름이 있는지 검사 - 부모 카테고리(parent_id)가 있다면, 해당 카테고리가 존재하고 현재 사용자가 소유한 카테고리여야 함
	 * @summary Create Category
	 * @param {CategoryCreate} categoryCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryApi
	 */
	public categoryCreateCategory(
		categoryCreate: CategoryCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CategoryApiFp(this.configuration)
			.categoryCreateCategory(categoryCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 카테고리 삭제
	 * @summary Delete Category
	 * @param {string} categoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryApi
	 */
	public categoryDeleteCategory(
		categoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CategoryApiFp(this.configuration)
			.categoryDeleteCategory(categoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 카테고리 목록 조회
	 * @summary Read Categories
	 * @param {string | null} [appName]
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryApi
	 */
	public categoryReadCategories(
		appName?: string | null,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CategoryApiFp(this.configuration)
			.categoryReadCategories(appName, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 카테고리 상세 조회
	 * @summary Read Category
	 * @param {string} categoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryApi
	 */
	public categoryReadCategory(
		categoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CategoryApiFp(this.configuration)
			.categoryReadCategory(categoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 카테고리 수정
	 * @summary Update Category
	 * @param {string} categoryId
	 * @param {CategoryUpdate} categoryUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof CategoryApi
	 */
	public categoryUpdateCategory(
		categoryId: string,
		categoryUpdate: CategoryUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return CategoryApiFp(this.configuration)
			.categoryUpdateCategory(categoryId, categoryUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 채널 생성
		 * @summary Create Channel
		 * @param {SalesChannelCreate} salesChannelCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelCreateChannel: async (
			salesChannelCreate: SalesChannelCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'salesChannelCreate' is not null or undefined
			assertParamExists(
				"channelCreateChannel",
				"salesChannelCreate",
				salesChannelCreate,
			);
			const localVarPath = `/api/v1/channels/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				salesChannelCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 삭제
		 * @summary Delete Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelDeleteChannel: async (
			channelId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelId' is not null or undefined
			assertParamExists("channelDeleteChannel", "channelId", channelId);
			const localVarPath = `/api/v1/channels/{channel_id}`.replace(
				`{${"channel_id"}}`,
				encodeURIComponent(String(channelId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 상세 조회
		 * @summary Read Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelReadChannel: async (
			channelId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelId' is not null or undefined
			assertParamExists("channelReadChannel", "channelId", channelId);
			const localVarPath = `/api/v1/channels/{channel_id}`.replace(
				`{${"channel_id"}}`,
				encodeURIComponent(String(channelId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 목록 조회
		 * @summary Read Channels
		 * @param {string | null} [appName]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelReadChannels: async (
			appName?: string | null,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/channels/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			if (appName !== undefined) {
				localVarQueryParameter["app_name"] = appName;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 수정
		 * @summary Update Channel
		 * @param {string} channelId
		 * @param {SalesChannelUpdate} salesChannelUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelUpdateChannel: async (
			channelId: string,
			salesChannelUpdate: SalesChannelUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelId' is not null or undefined
			assertParamExists("channelUpdateChannel", "channelId", channelId);
			// verify required parameter 'salesChannelUpdate' is not null or undefined
			assertParamExists(
				"channelUpdateChannel",
				"salesChannelUpdate",
				salesChannelUpdate,
			);
			const localVarPath = `/api/v1/channels/{channel_id}`.replace(
				`{${"channel_id"}}`,
				encodeURIComponent(String(channelId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				salesChannelUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ChannelApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 채널 생성
		 * @summary Create Channel
		 * @param {SalesChannelCreate} salesChannelCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async channelCreateChannel(
			salesChannelCreate: SalesChannelCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SalesChannel>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.channelCreateChannel(
					salesChannelCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ChannelApi.channelCreateChannel"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 삭제
		 * @summary Delete Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async channelDeleteChannel(
			channelId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.channelDeleteChannel(
					channelId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ChannelApi.channelDeleteChannel"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 상세 조회
		 * @summary Read Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async channelReadChannel(
			channelId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SalesChannel>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.channelReadChannel(
					channelId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ChannelApi.channelReadChannel"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 목록 조회
		 * @summary Read Channels
		 * @param {string | null} [appName]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async channelReadChannels(
			appName?: string | null,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<SalesChannel>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.channelReadChannels(
					appName,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ChannelApi.channelReadChannels"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 수정
		 * @summary Update Channel
		 * @param {string} channelId
		 * @param {SalesChannelUpdate} salesChannelUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async channelUpdateChannel(
			channelId: string,
			salesChannelUpdate: SalesChannelUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SalesChannel>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.channelUpdateChannel(
					channelId,
					salesChannelUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ChannelApi.channelUpdateChannel"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = ChannelApiFp(configuration);
	return {
		/**
		 * 신규 채널 생성
		 * @summary Create Channel
		 * @param {SalesChannelCreate} salesChannelCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelCreateChannel(
			salesChannelCreate: SalesChannelCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<SalesChannel> {
			return localVarFp
				.channelCreateChannel(salesChannelCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 삭제
		 * @summary Delete Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelDeleteChannel(
			channelId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.channelDeleteChannel(channelId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 상세 조회
		 * @summary Read Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelReadChannel(
			channelId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<SalesChannel> {
			return localVarFp
				.channelReadChannel(channelId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 목록 조회
		 * @summary Read Channels
		 * @param {string | null} [appName]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelReadChannels(
			appName?: string | null,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<SalesChannel>> {
			return localVarFp
				.channelReadChannels(appName, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 수정
		 * @summary Update Channel
		 * @param {string} channelId
		 * @param {SalesChannelUpdate} salesChannelUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		channelUpdateChannel(
			channelId: string,
			salesChannelUpdate: SalesChannelUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<SalesChannel> {
			return localVarFp
				.channelUpdateChannel(
					channelId,
					salesChannelUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI {
	/**
	 * 신규 채널 생성
	 * @summary Create Channel
	 * @param {SalesChannelCreate} salesChannelCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChannelApi
	 */
	public channelCreateChannel(
		salesChannelCreate: SalesChannelCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ChannelApiFp(this.configuration)
			.channelCreateChannel(salesChannelCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 삭제
	 * @summary Delete Channel
	 * @param {string} channelId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChannelApi
	 */
	public channelDeleteChannel(
		channelId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ChannelApiFp(this.configuration)
			.channelDeleteChannel(channelId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 상세 조회
	 * @summary Read Channel
	 * @param {string} channelId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChannelApi
	 */
	public channelReadChannel(
		channelId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ChannelApiFp(this.configuration)
			.channelReadChannel(channelId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 목록 조회
	 * @summary Read Channels
	 * @param {string | null} [appName]
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChannelApi
	 */
	public channelReadChannels(
		appName?: string | null,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ChannelApiFp(this.configuration)
			.channelReadChannels(appName, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 수정
	 * @summary Update Channel
	 * @param {string} channelId
	 * @param {SalesChannelUpdate} salesChannelUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ChannelApi
	 */
	public channelUpdateChannel(
		channelId: string,
		salesChannelUpdate: SalesChannelUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ChannelApiFp(this.configuration)
			.channelUpdateChannel(channelId, salesChannelUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * HealthCheckApi - axios parameter creator
 * @export
 */
export const HealthCheckApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary Health Check
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthCheckHealthCheck: async (
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/health-check`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		HealthCheckApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Health Check
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async healthCheckHealthCheck(
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.healthCheckHealthCheck(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["HealthCheckApi.healthCheckHealthCheck"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = HealthCheckApiFp(configuration);
	return {
		/**
		 *
		 * @summary Health Check
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthCheckHealthCheck(
			options?: RawAxiosRequestConfig,
		): AxiosPromise<boolean> {
			return localVarFp
				.healthCheckHealthCheck(options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI {
	/**
	 *
	 * @summary Health Check
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HealthCheckApi
	 */
	public healthCheckHealthCheck(options?: RawAxiosRequestConfig) {
		return HealthCheckApiFp(this.configuration)
			.healthCheckHealthCheck(options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * InventoryApi - axios parameter creator
 * @export
 */
export const InventoryApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 인벤토리 생성
		 * @summary Create Inventory
		 * @param {InventoryCreate} inventoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryCreateInventory: async (
			inventoryCreate: InventoryCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryCreate' is not null or undefined
			assertParamExists(
				"inventoryCreateInventory",
				"inventoryCreate",
				inventoryCreate,
			);
			const localVarPath = `/api/v1/inventories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				inventoryCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 인벤토리 삭제
		 * @summary Delete Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryDeleteInventory: async (
			inventoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists("inventoryDeleteInventory", "inventoryId", inventoryId);
			const localVarPath = `/api/v1/inventories/{inventory_id}`.replace(
				`{${"inventory_id"}}`,
				encodeURIComponent(String(inventoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 인벤토리 목록 조회
		 * @summary Read Inventories
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryReadInventories: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/inventories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 인벤토리 조회
		 * @summary Read Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryReadInventory: async (
			inventoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists("inventoryReadInventory", "inventoryId", inventoryId);
			const localVarPath = `/api/v1/inventories/{inventory_id}`.replace(
				`{${"inventory_id"}}`,
				encodeURIComponent(String(inventoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 인벤토리 정보 수정
		 * @summary Update Inventory
		 * @param {string} inventoryId
		 * @param {InventoryUpdate} inventoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryUpdateInventory: async (
			inventoryId: string,
			inventoryUpdate: InventoryUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists("inventoryUpdateInventory", "inventoryId", inventoryId);
			// verify required parameter 'inventoryUpdate' is not null or undefined
			assertParamExists(
				"inventoryUpdateInventory",
				"inventoryUpdate",
				inventoryUpdate,
			);
			const localVarPath = `/api/v1/inventories/{inventory_id}`.replace(
				`{${"inventory_id"}}`,
				encodeURIComponent(String(inventoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				inventoryUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		InventoryApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 인벤토리 생성
		 * @summary Create Inventory
		 * @param {InventoryCreate} inventoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async inventoryCreateInventory(
			inventoryCreate: InventoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inventory>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.inventoryCreateInventory(
					inventoryCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["InventoryApi.inventoryCreateInventory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 인벤토리 삭제
		 * @summary Delete Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async inventoryDeleteInventory(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.inventoryDeleteInventory(
					inventoryId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["InventoryApi.inventoryDeleteInventory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 인벤토리 목록 조회
		 * @summary Read Inventories
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async inventoryReadInventories(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<Inventory>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.inventoryReadInventories(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["InventoryApi.inventoryReadInventories"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 인벤토리 조회
		 * @summary Read Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async inventoryReadInventory(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inventory>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.inventoryReadInventory(
					inventoryId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["InventoryApi.inventoryReadInventory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 인벤토리 정보 수정
		 * @summary Update Inventory
		 * @param {string} inventoryId
		 * @param {InventoryUpdate} inventoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async inventoryUpdateInventory(
			inventoryId: string,
			inventoryUpdate: InventoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inventory>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.inventoryUpdateInventory(
					inventoryId,
					inventoryUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["InventoryApi.inventoryUpdateInventory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = InventoryApiFp(configuration);
	return {
		/**
		 * 신규 인벤토리 생성
		 * @summary Create Inventory
		 * @param {InventoryCreate} inventoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryCreateInventory(
			inventoryCreate: InventoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Inventory> {
			return localVarFp
				.inventoryCreateInventory(inventoryCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 인벤토리 삭제
		 * @summary Delete Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryDeleteInventory(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.inventoryDeleteInventory(inventoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 인벤토리 목록 조회
		 * @summary Read Inventories
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryReadInventories(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Inventory>> {
			return localVarFp
				.inventoryReadInventories(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 인벤토리 조회
		 * @summary Read Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryReadInventory(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Inventory> {
			return localVarFp
				.inventoryReadInventory(inventoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 인벤토리 정보 수정
		 * @summary Update Inventory
		 * @param {string} inventoryId
		 * @param {InventoryUpdate} inventoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryUpdateInventory(
			inventoryId: string,
			inventoryUpdate: InventoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Inventory> {
			return localVarFp
				.inventoryUpdateInventory(
					inventoryId,
					inventoryUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
	/**
	 * 신규 인벤토리 생성
	 * @summary Create Inventory
	 * @param {InventoryCreate} inventoryCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof InventoryApi
	 */
	public inventoryCreateInventory(
		inventoryCreate: InventoryCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return InventoryApiFp(this.configuration)
			.inventoryCreateInventory(inventoryCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 인벤토리 삭제
	 * @summary Delete Inventory
	 * @param {string} inventoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof InventoryApi
	 */
	public inventoryDeleteInventory(
		inventoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return InventoryApiFp(this.configuration)
			.inventoryDeleteInventory(inventoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 인벤토리 목록 조회
	 * @summary Read Inventories
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof InventoryApi
	 */
	public inventoryReadInventories(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return InventoryApiFp(this.configuration)
			.inventoryReadInventories(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 인벤토리 조회
	 * @summary Read Inventory
	 * @param {string} inventoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof InventoryApi
	 */
	public inventoryReadInventory(
		inventoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return InventoryApiFp(this.configuration)
			.inventoryReadInventory(inventoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 인벤토리 정보 수정
	 * @summary Update Inventory
	 * @param {string} inventoryId
	 * @param {InventoryUpdate} inventoryUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof InventoryApi
	 */
	public inventoryUpdateInventory(
		inventoryId: string,
		inventoryUpdate: InventoryUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return InventoryApiFp(this.configuration)
			.inventoryUpdateInventory(
				inventoryId,
				inventoryUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * InventoryTransactionApi - axios parameter creator
 * @export
 */
export const InventoryTransactionApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 재고 생성
		 * @summary Create Invetory Transaction
		 * @param {string} inventoryId
		 * @param {InventoryTransactionRequest} inventoryTransactionRequest
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryTransactionCreateInvetoryTransaction: async (
			inventoryId: string,
			inventoryTransactionRequest: InventoryTransactionRequest,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists(
				"inventoryTransactionCreateInvetoryTransaction",
				"inventoryId",
				inventoryId,
			);
			// verify required parameter 'inventoryTransactionRequest' is not null or undefined
			assertParamExists(
				"inventoryTransactionCreateInvetoryTransaction",
				"inventoryTransactionRequest",
				inventoryTransactionRequest,
			);
			const localVarPath =
				`/api/v1/inventories/{inventory_id}/transactions`.replace(
					`{${"inventory_id"}}`,
					encodeURIComponent(String(inventoryId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				inventoryTransactionRequest,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 재고 거래 내역 상세 조회
		 * @summary Read Inventory Transaction
		 * @param {string} inventoryId
		 * @param {string} transactionId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryTransactionReadInventoryTransaction: async (
			inventoryId: string,
			transactionId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists(
				"inventoryTransactionReadInventoryTransaction",
				"inventoryId",
				inventoryId,
			);
			// verify required parameter 'transactionId' is not null or undefined
			assertParamExists(
				"inventoryTransactionReadInventoryTransaction",
				"transactionId",
				transactionId,
			);
			const localVarPath =
				`/api/v1/inventories/{inventory_id}/transactions/{transaction_id}`
					.replace(
						`{${"inventory_id"}}`,
						encodeURIComponent(String(inventoryId)),
					)
					.replace(
						`{${"transaction_id"}}`,
						encodeURIComponent(String(transactionId)),
					);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 재고 거래 내역 조회
		 * @summary Read Inventory Transactions
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryTransactionReadInventoryTransactions: async (
			inventoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists(
				"inventoryTransactionReadInventoryTransactions",
				"inventoryId",
				inventoryId,
			);
			const localVarPath =
				`/api/v1/inventories/{inventory_id}/transactions`.replace(
					`{${"inventory_id"}}`,
					encodeURIComponent(String(inventoryId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * InventoryTransactionApi - functional programming interface
 * @export
 */
export const InventoryTransactionApiFp = function (
	configuration?: Configuration,
) {
	const localVarAxiosParamCreator =
		InventoryTransactionApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 재고 생성
		 * @summary Create Invetory Transaction
		 * @param {string} inventoryId
		 * @param {InventoryTransactionRequest} inventoryTransactionRequest
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async inventoryTransactionCreateInvetoryTransaction(
			inventoryId: string,
			inventoryTransactionRequest: InventoryTransactionRequest,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<InventoryTransaction>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.inventoryTransactionCreateInvetoryTransaction(
					inventoryId,
					inventoryTransactionRequest,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"InventoryTransactionApi.inventoryTransactionCreateInvetoryTransaction"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 재고 거래 내역 상세 조회
		 * @summary Read Inventory Transaction
		 * @param {string} inventoryId
		 * @param {string} transactionId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async inventoryTransactionReadInventoryTransaction(
			inventoryId: string,
			transactionId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<InventoryTransaction>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.inventoryTransactionReadInventoryTransaction(
					inventoryId,
					transactionId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"InventoryTransactionApi.inventoryTransactionReadInventoryTransaction"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 재고 거래 내역 조회
		 * @summary Read Inventory Transactions
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async inventoryTransactionReadInventoryTransactions(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<InventoryTransaction>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.inventoryTransactionReadInventoryTransactions(
					inventoryId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"InventoryTransactionApi.inventoryTransactionReadInventoryTransactions"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * InventoryTransactionApi - factory interface
 * @export
 */
export const InventoryTransactionApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = InventoryTransactionApiFp(configuration);
	return {
		/**
		 * 신규 재고 생성
		 * @summary Create Invetory Transaction
		 * @param {string} inventoryId
		 * @param {InventoryTransactionRequest} inventoryTransactionRequest
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryTransactionCreateInvetoryTransaction(
			inventoryId: string,
			inventoryTransactionRequest: InventoryTransactionRequest,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<InventoryTransaction> {
			return localVarFp
				.inventoryTransactionCreateInvetoryTransaction(
					inventoryId,
					inventoryTransactionRequest,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 재고 거래 내역 상세 조회
		 * @summary Read Inventory Transaction
		 * @param {string} inventoryId
		 * @param {string} transactionId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryTransactionReadInventoryTransaction(
			inventoryId: string,
			transactionId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<InventoryTransaction> {
			return localVarFp
				.inventoryTransactionReadInventoryTransaction(
					inventoryId,
					transactionId,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 재고 거래 내역 조회
		 * @summary Read Inventory Transactions
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		inventoryTransactionReadInventoryTransactions(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<InventoryTransaction>> {
			return localVarFp
				.inventoryTransactionReadInventoryTransactions(
					inventoryId,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * InventoryTransactionApi - object-oriented interface
 * @export
 * @class InventoryTransactionApi
 * @extends {BaseAPI}
 */
export class InventoryTransactionApi extends BaseAPI {
	/**
	 * 신규 재고 생성
	 * @summary Create Invetory Transaction
	 * @param {string} inventoryId
	 * @param {InventoryTransactionRequest} inventoryTransactionRequest
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof InventoryTransactionApi
	 */
	public inventoryTransactionCreateInvetoryTransaction(
		inventoryId: string,
		inventoryTransactionRequest: InventoryTransactionRequest,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return InventoryTransactionApiFp(this.configuration)
			.inventoryTransactionCreateInvetoryTransaction(
				inventoryId,
				inventoryTransactionRequest,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 재고 거래 내역 상세 조회
	 * @summary Read Inventory Transaction
	 * @param {string} inventoryId
	 * @param {string} transactionId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof InventoryTransactionApi
	 */
	public inventoryTransactionReadInventoryTransaction(
		inventoryId: string,
		transactionId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return InventoryTransactionApiFp(this.configuration)
			.inventoryTransactionReadInventoryTransaction(
				inventoryId,
				transactionId,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 재고 거래 내역 조회
	 * @summary Read Inventory Transactions
	 * @param {string} inventoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof InventoryTransactionApi
	 */
	public inventoryTransactionReadInventoryTransactions(
		inventoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return InventoryTransactionApiFp(this.configuration)
			.inventoryTransactionReadInventoryTransactions(
				inventoryId,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * ListingApi - axios parameter creator
 * @export
 */
export const ListingApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 채널 리스팅 생성
		 * @summary Create Channel Listing
		 * @param {ChannelListingCreate} channelListingCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingCreateChannelListing: async (
			channelListingCreate: ChannelListingCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelListingCreate' is not null or undefined
			assertParamExists(
				"listingCreateChannelListing",
				"channelListingCreate",
				channelListingCreate,
			);
			const localVarPath = `/api/v1/listings/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				channelListingCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 리스팅 삭제
		 * @summary Delete Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingDeleteChannelListing: async (
			channelListingId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelListingId' is not null or undefined
			assertParamExists(
				"listingDeleteChannelListing",
				"channelListingId",
				channelListingId,
			);
			const localVarPath = `/api/v1/listings/{channel_listing_id}`.replace(
				`{${"channel_listing_id"}}`,
				encodeURIComponent(String(channelListingId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 리스팅 상세 조회
		 * @summary Read Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingReadChannelListing: async (
			channelListingId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelListingId' is not null or undefined
			assertParamExists(
				"listingReadChannelListing",
				"channelListingId",
				channelListingId,
			);
			const localVarPath = `/api/v1/listings/{channel_listing_id}`.replace(
				`{${"channel_listing_id"}}`,
				encodeURIComponent(String(channelListingId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 리스팅 목록 조회
		 * @summary Read Channel Listings
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingReadChannelListings: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/listings/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 리스팅 정보 수정
		 * @summary Update Channel Listing
		 * @param {string} channelListingId
		 * @param {ChannelListingUpdate} channelListingUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingUpdateChannelListing: async (
			channelListingId: string,
			channelListingUpdate: ChannelListingUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelListingId' is not null or undefined
			assertParamExists(
				"listingUpdateChannelListing",
				"channelListingId",
				channelListingId,
			);
			// verify required parameter 'channelListingUpdate' is not null or undefined
			assertParamExists(
				"listingUpdateChannelListing",
				"channelListingUpdate",
				channelListingUpdate,
			);
			const localVarPath = `/api/v1/listings/{channel_listing_id}`.replace(
				`{${"channel_listing_id"}}`,
				encodeURIComponent(String(channelListingId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				channelListingUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * ListingApi - functional programming interface
 * @export
 */
export const ListingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ListingApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 채널 리스팅 생성
		 * @summary Create Channel Listing
		 * @param {ChannelListingCreate} channelListingCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async listingCreateChannelListing(
			channelListingCreate: ChannelListingCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelListing>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.listingCreateChannelListing(
					channelListingCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ListingApi.listingCreateChannelListing"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 리스팅 삭제
		 * @summary Delete Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async listingDeleteChannelListing(
			channelListingId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.listingDeleteChannelListing(
					channelListingId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ListingApi.listingDeleteChannelListing"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 리스팅 상세 조회
		 * @summary Read Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async listingReadChannelListing(
			channelListingId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelListing>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.listingReadChannelListing(
					channelListingId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ListingApi.listingReadChannelListing"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 리스팅 목록 조회
		 * @summary Read Channel Listings
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async listingReadChannelListings(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<ChannelListing>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.listingReadChannelListings(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ListingApi.listingReadChannelListings"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 리스팅 정보 수정
		 * @summary Update Channel Listing
		 * @param {string} channelListingId
		 * @param {ChannelListingUpdate} channelListingUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async listingUpdateChannelListing(
			channelListingId: string,
			channelListingUpdate: ChannelListingUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelListing>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.listingUpdateChannelListing(
					channelListingId,
					channelListingUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ListingApi.listingUpdateChannelListing"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * ListingApi - factory interface
 * @export
 */
export const ListingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = ListingApiFp(configuration);
	return {
		/**
		 * 신규 채널 리스팅 생성
		 * @summary Create Channel Listing
		 * @param {ChannelListingCreate} channelListingCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingCreateChannelListing(
			channelListingCreate: ChannelListingCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ChannelListing> {
			return localVarFp
				.listingCreateChannelListing(channelListingCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 리스팅 삭제
		 * @summary Delete Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingDeleteChannelListing(
			channelListingId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.listingDeleteChannelListing(channelListingId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 리스팅 상세 조회
		 * @summary Read Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingReadChannelListing(
			channelListingId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ChannelListing> {
			return localVarFp
				.listingReadChannelListing(channelListingId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 리스팅 목록 조회
		 * @summary Read Channel Listings
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingReadChannelListings(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<ChannelListing>> {
			return localVarFp
				.listingReadChannelListings(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 리스팅 정보 수정
		 * @summary Update Channel Listing
		 * @param {string} channelListingId
		 * @param {ChannelListingUpdate} channelListingUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		listingUpdateChannelListing(
			channelListingId: string,
			channelListingUpdate: ChannelListingUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ChannelListing> {
			return localVarFp
				.listingUpdateChannelListing(
					channelListingId,
					channelListingUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * ListingApi - object-oriented interface
 * @export
 * @class ListingApi
 * @extends {BaseAPI}
 */
export class ListingApi extends BaseAPI {
	/**
	 * 신규 채널 리스팅 생성
	 * @summary Create Channel Listing
	 * @param {ChannelListingCreate} channelListingCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ListingApi
	 */
	public listingCreateChannelListing(
		channelListingCreate: ChannelListingCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ListingApiFp(this.configuration)
			.listingCreateChannelListing(channelListingCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 리스팅 삭제
	 * @summary Delete Channel Listing
	 * @param {string} channelListingId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ListingApi
	 */
	public listingDeleteChannelListing(
		channelListingId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ListingApiFp(this.configuration)
			.listingDeleteChannelListing(channelListingId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 리스팅 상세 조회
	 * @summary Read Channel Listing
	 * @param {string} channelListingId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ListingApi
	 */
	public listingReadChannelListing(
		channelListingId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ListingApiFp(this.configuration)
			.listingReadChannelListing(channelListingId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 리스팅 목록 조회
	 * @summary Read Channel Listings
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ListingApi
	 */
	public listingReadChannelListings(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ListingApiFp(this.configuration)
			.listingReadChannelListings(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 리스팅 정보 수정
	 * @summary Update Channel Listing
	 * @param {string} channelListingId
	 * @param {ChannelListingUpdate} channelListingUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ListingApi
	 */
	public listingUpdateChannelListing(
		channelListingId: string,
		channelListingUpdate: ChannelListingUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ListingApiFp(this.configuration)
			.listingUpdateChannelListing(
				channelListingId,
				channelListingUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 주문 생성
		 * @summary Create Order
		 * @param {OrderCreate} orderCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderCreateOrder: async (
			orderCreate: OrderCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderCreate' is not null or undefined
			assertParamExists("orderCreateOrder", "orderCreate", orderCreate);
			const localVarPath = `/api/v1/orders/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				orderCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문에 상품 추가
		 * @summary Create Order Line Item
		 * @param {string} orderId
		 * @param {OrderLineItemCreate} orderLineItemCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderCreateOrderLineItem: async (
			orderId: string,
			orderLineItemCreate: OrderLineItemCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("orderCreateOrderLineItem", "orderId", orderId);
			// verify required parameter 'orderLineItemCreate' is not null or undefined
			assertParamExists(
				"orderCreateOrderLineItem",
				"orderLineItemCreate",
				orderLineItemCreate,
			);
			const localVarPath = `/api/v1/orders/{order_id}/line-items`.replace(
				`{${"order_id"}}`,
				encodeURIComponent(String(orderId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				orderLineItemCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문의 상품 삭제
		 * @summary Delete Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderDeleteOrderLineItem: async (
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("orderDeleteOrderLineItem", "orderId", orderId);
			// verify required parameter 'lineItemId' is not null or undefined
			assertParamExists("orderDeleteOrderLineItem", "lineItemId", lineItemId);
			const localVarPath = `/api/v1/orders/{order_id}/line-items/{line_item_id}`
				.replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
				.replace(`{${"line_item_id"}}`, encodeURIComponent(String(lineItemId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문 상세 조회
		 * @summary Read Order
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderReadOrder: async (
			orderId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("orderReadOrder", "orderId", orderId);
			const localVarPath = `/api/v1/orders/{order_id}`.replace(
				`{${"order_id"}}`,
				encodeURIComponent(String(orderId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문의 상품 상세 조회
		 * @summary Read Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderReadOrderLineItem: async (
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("orderReadOrderLineItem", "orderId", orderId);
			// verify required parameter 'lineItemId' is not null or undefined
			assertParamExists("orderReadOrderLineItem", "lineItemId", lineItemId);
			const localVarPath = `/api/v1/orders/{order_id}/line-items/{line_item_id}`
				.replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
				.replace(`{${"line_item_id"}}`, encodeURIComponent(String(lineItemId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문의 상품 목록 조회
		 * @summary Read Order Line Items
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderReadOrderLineItems: async (
			orderId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("orderReadOrderLineItems", "orderId", orderId);
			const localVarPath = `/api/v1/orders/{order_id}/line-items`.replace(
				`{${"order_id"}}`,
				encodeURIComponent(String(orderId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문 목록 조회
		 * @summary Read Orders
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderReadOrders: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/orders/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문 수정
		 * @summary Update Order
		 * @param {string} orderId
		 * @param {OrderUpdate} orderUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderUpdateOrder: async (
			orderId: string,
			orderUpdate: OrderUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("orderUpdateOrder", "orderId", orderId);
			// verify required parameter 'orderUpdate' is not null or undefined
			assertParamExists("orderUpdateOrder", "orderUpdate", orderUpdate);
			const localVarPath = `/api/v1/orders/{order_id}`.replace(
				`{${"order_id"}}`,
				encodeURIComponent(String(orderId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				orderUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문의 상품 수정
		 * @summary Update Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {OrderLineItemUpdate} orderLineItemUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderUpdateOrderLineItem: async (
			orderId: string,
			lineItemId: string,
			orderLineItemUpdate: OrderLineItemUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("orderUpdateOrderLineItem", "orderId", orderId);
			// verify required parameter 'lineItemId' is not null or undefined
			assertParamExists("orderUpdateOrderLineItem", "lineItemId", lineItemId);
			// verify required parameter 'orderLineItemUpdate' is not null or undefined
			assertParamExists(
				"orderUpdateOrderLineItem",
				"orderLineItemUpdate",
				orderLineItemUpdate,
			);
			const localVarPath = `/api/v1/orders/{order_id}/line-items/{line_item_id}`
				.replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
				.replace(`{${"line_item_id"}}`, encodeURIComponent(String(lineItemId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				orderLineItemUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 주문 생성
		 * @summary Create Order
		 * @param {OrderCreate} orderCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async orderCreateOrder(
			orderCreate: OrderCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.orderCreateOrder(
					orderCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["OrderApi.orderCreateOrder"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문에 상품 추가
		 * @summary Create Order Line Item
		 * @param {string} orderId
		 * @param {OrderLineItemCreate} orderLineItemCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async orderCreateOrderLineItem(
			orderId: string,
			orderLineItemCreate: OrderLineItemCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderLineItem>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.orderCreateOrderLineItem(
					orderId,
					orderLineItemCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["OrderApi.orderCreateOrderLineItem"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문의 상품 삭제
		 * @summary Delete Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async orderDeleteOrderLineItem(
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.orderDeleteOrderLineItem(
					orderId,
					lineItemId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["OrderApi.orderDeleteOrderLineItem"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문 상세 조회
		 * @summary Read Order
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async orderReadOrder(
			orderId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.orderReadOrder(
				orderId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["OrderApi.orderReadOrder"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문의 상품 상세 조회
		 * @summary Read Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async orderReadOrderLineItem(
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderLineItem>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.orderReadOrderLineItem(
					orderId,
					lineItemId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["OrderApi.orderReadOrderLineItem"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문의 상품 목록 조회
		 * @summary Read Order Line Items
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async orderReadOrderLineItems(
			orderId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<OrderLineItem>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.orderReadOrderLineItems(
					orderId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["OrderApi.orderReadOrderLineItems"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문 목록 조회
		 * @summary Read Orders
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async orderReadOrders(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.orderReadOrders(
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["OrderApi.orderReadOrders"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문 수정
		 * @summary Update Order
		 * @param {string} orderId
		 * @param {OrderUpdate} orderUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async orderUpdateOrder(
			orderId: string,
			orderUpdate: OrderUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.orderUpdateOrder(
					orderId,
					orderUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["OrderApi.orderUpdateOrder"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문의 상품 수정
		 * @summary Update Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {OrderLineItemUpdate} orderLineItemUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async orderUpdateOrderLineItem(
			orderId: string,
			lineItemId: string,
			orderLineItemUpdate: OrderLineItemUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderLineItem>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.orderUpdateOrderLineItem(
					orderId,
					lineItemId,
					orderLineItemUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["OrderApi.orderUpdateOrderLineItem"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = OrderApiFp(configuration);
	return {
		/**
		 * 신규 주문 생성
		 * @summary Create Order
		 * @param {OrderCreate} orderCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderCreateOrder(
			orderCreate: OrderCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Order> {
			return localVarFp
				.orderCreateOrder(orderCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문에 상품 추가
		 * @summary Create Order Line Item
		 * @param {string} orderId
		 * @param {OrderLineItemCreate} orderLineItemCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderCreateOrderLineItem(
			orderId: string,
			orderLineItemCreate: OrderLineItemCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<OrderLineItem> {
			return localVarFp
				.orderCreateOrderLineItem(
					orderId,
					orderLineItemCreate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문의 상품 삭제
		 * @summary Delete Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderDeleteOrderLineItem(
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.orderDeleteOrderLineItem(orderId, lineItemId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문 상세 조회
		 * @summary Read Order
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderReadOrder(
			orderId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Order> {
			return localVarFp
				.orderReadOrder(orderId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문의 상품 상세 조회
		 * @summary Read Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderReadOrderLineItem(
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<OrderLineItem> {
			return localVarFp
				.orderReadOrderLineItem(orderId, lineItemId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문의 상품 목록 조회
		 * @summary Read Order Line Items
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderReadOrderLineItems(
			orderId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<OrderLineItem>> {
			return localVarFp
				.orderReadOrderLineItems(orderId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문 목록 조회
		 * @summary Read Orders
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderReadOrders(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Order>> {
			return localVarFp
				.orderReadOrders(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문 수정
		 * @summary Update Order
		 * @param {string} orderId
		 * @param {OrderUpdate} orderUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderUpdateOrder(
			orderId: string,
			orderUpdate: OrderUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Order> {
			return localVarFp
				.orderUpdateOrder(orderId, orderUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문의 상품 수정
		 * @summary Update Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {OrderLineItemUpdate} orderLineItemUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		orderUpdateOrderLineItem(
			orderId: string,
			lineItemId: string,
			orderLineItemUpdate: OrderLineItemUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<OrderLineItem> {
			return localVarFp
				.orderUpdateOrderLineItem(
					orderId,
					lineItemId,
					orderLineItemUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
	/**
	 * 신규 주문 생성
	 * @summary Create Order
	 * @param {OrderCreate} orderCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrderApi
	 */
	public orderCreateOrder(
		orderCreate: OrderCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return OrderApiFp(this.configuration)
			.orderCreateOrder(orderCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문에 상품 추가
	 * @summary Create Order Line Item
	 * @param {string} orderId
	 * @param {OrderLineItemCreate} orderLineItemCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrderApi
	 */
	public orderCreateOrderLineItem(
		orderId: string,
		orderLineItemCreate: OrderLineItemCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return OrderApiFp(this.configuration)
			.orderCreateOrderLineItem(
				orderId,
				orderLineItemCreate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문의 상품 삭제
	 * @summary Delete Order Line Item
	 * @param {string} orderId
	 * @param {string} lineItemId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrderApi
	 */
	public orderDeleteOrderLineItem(
		orderId: string,
		lineItemId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return OrderApiFp(this.configuration)
			.orderDeleteOrderLineItem(orderId, lineItemId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문 상세 조회
	 * @summary Read Order
	 * @param {string} orderId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrderApi
	 */
	public orderReadOrder(
		orderId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return OrderApiFp(this.configuration)
			.orderReadOrder(orderId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문의 상품 상세 조회
	 * @summary Read Order Line Item
	 * @param {string} orderId
	 * @param {string} lineItemId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrderApi
	 */
	public orderReadOrderLineItem(
		orderId: string,
		lineItemId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return OrderApiFp(this.configuration)
			.orderReadOrderLineItem(orderId, lineItemId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문의 상품 목록 조회
	 * @summary Read Order Line Items
	 * @param {string} orderId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrderApi
	 */
	public orderReadOrderLineItems(
		orderId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return OrderApiFp(this.configuration)
			.orderReadOrderLineItems(orderId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문 목록 조회
	 * @summary Read Orders
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrderApi
	 */
	public orderReadOrders(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return OrderApiFp(this.configuration)
			.orderReadOrders(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문 수정
	 * @summary Update Order
	 * @param {string} orderId
	 * @param {OrderUpdate} orderUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrderApi
	 */
	public orderUpdateOrder(
		orderId: string,
		orderUpdate: OrderUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return OrderApiFp(this.configuration)
			.orderUpdateOrder(orderId, orderUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문의 상품 수정
	 * @summary Update Order Line Item
	 * @param {string} orderId
	 * @param {string} lineItemId
	 * @param {OrderLineItemUpdate} orderLineItemUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof OrderApi
	 */
	public orderUpdateOrderLineItem(
		orderId: string,
		lineItemId: string,
		orderLineItemUpdate: OrderLineItemUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return OrderApiFp(this.configuration)
			.orderUpdateOrderLineItem(
				orderId,
				lineItemId,
				orderLineItemUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 상품 생성 - 사용자가 소유한 상품 중 동일한 이름이 있는지 검사
		 * @summary Create Product
		 * @param {ProductCreate} productCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productCreateProduct: async (
			productCreate: ProductCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productCreate' is not null or undefined
			assertParamExists("productCreateProduct", "productCreate", productCreate);
			const localVarPath = `/api/v1/products/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				productCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 삭제
		 * @summary Delete Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productDeleteProduct: async (
			productId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("productDeleteProduct", "productId", productId);
			const localVarPath = `/api/v1/products/{product_id}`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 상세 조회
		 * @summary Read Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productReadProduct: async (
			productId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("productReadProduct", "productId", productId);
			const localVarPath = `/api/v1/products/{product_id}`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 목록 조회
		 * @summary Read Products
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productReadProducts: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/products/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 수정
		 * @summary Update Product
		 * @param {string} productId
		 * @param {ProductUpdate} productUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productUpdateProduct: async (
			productId: string,
			productUpdate: ProductUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("productUpdateProduct", "productId", productId);
			// verify required parameter 'productUpdate' is not null or undefined
			assertParamExists("productUpdateProduct", "productUpdate", productUpdate);
			const localVarPath = `/api/v1/products/{product_id}`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				productUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 상품 생성 - 사용자가 소유한 상품 중 동일한 이름이 있는지 검사
		 * @summary Create Product
		 * @param {ProductCreate} productCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productCreateProduct(
			productCreate: ProductCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productCreateProduct(
					productCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ProductApi.productCreateProduct"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 삭제
		 * @summary Delete Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productDeleteProduct(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productDeleteProduct(
					productId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ProductApi.productDeleteProduct"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 상세 조회
		 * @summary Read Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productReadProduct(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productReadProduct(
					productId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ProductApi.productReadProduct"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 목록 조회
		 * @summary Read Products
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productReadProducts(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productReadProducts(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ProductApi.productReadProducts"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 수정
		 * @summary Update Product
		 * @param {string} productId
		 * @param {ProductUpdate} productUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productUpdateProduct(
			productId: string,
			productUpdate: ProductUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productUpdateProduct(
					productId,
					productUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["ProductApi.productUpdateProduct"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = ProductApiFp(configuration);
	return {
		/**
		 * 신규 상품 생성 - 사용자가 소유한 상품 중 동일한 이름이 있는지 검사
		 * @summary Create Product
		 * @param {ProductCreate} productCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productCreateProduct(
			productCreate: ProductCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Product> {
			return localVarFp
				.productCreateProduct(productCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 삭제
		 * @summary Delete Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productDeleteProduct(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.productDeleteProduct(productId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 상세 조회
		 * @summary Read Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productReadProduct(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Product> {
			return localVarFp
				.productReadProduct(productId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 목록 조회
		 * @summary Read Products
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productReadProducts(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Product>> {
			return localVarFp
				.productReadProducts(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 수정
		 * @summary Update Product
		 * @param {string} productId
		 * @param {ProductUpdate} productUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productUpdateProduct(
			productId: string,
			productUpdate: ProductUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Product> {
			return localVarFp
				.productUpdateProduct(productId, productUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
	/**
	 * 신규 상품 생성 - 사용자가 소유한 상품 중 동일한 이름이 있는지 검사
	 * @summary Create Product
	 * @param {ProductCreate} productCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductApi
	 */
	public productCreateProduct(
		productCreate: ProductCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductApiFp(this.configuration)
			.productCreateProduct(productCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 삭제
	 * @summary Delete Product
	 * @param {string} productId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductApi
	 */
	public productDeleteProduct(
		productId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductApiFp(this.configuration)
			.productDeleteProduct(productId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 상세 조회
	 * @summary Read Product
	 * @param {string} productId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductApi
	 */
	public productReadProduct(
		productId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductApiFp(this.configuration)
			.productReadProduct(productId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 목록 조회
	 * @summary Read Products
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductApi
	 */
	public productReadProducts(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductApiFp(this.configuration)
			.productReadProducts(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 수정
	 * @summary Update Product
	 * @param {string} productId
	 * @param {ProductUpdate} productUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductApi
	 */
	public productUpdateProduct(
		productId: string,
		productUpdate: ProductUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductApiFp(this.configuration)
			.productUpdateProduct(productId, productUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * ProductVariantApi - axios parameter creator
 * @export
 */
export const ProductVariantApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 상품 옵션 생성
		 * @summary Create Product Variant
		 * @param {string} productId
		 * @param {ProductVariantCreate} productVariantCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantCreateProductVariant: async (
			productId: string,
			productVariantCreate: ProductVariantCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists(
				"productVariantCreateProductVariant",
				"productId",
				productId,
			);
			// verify required parameter 'productVariantCreate' is not null or undefined
			assertParamExists(
				"productVariantCreateProductVariant",
				"productVariantCreate",
				productVariantCreate,
			);
			const localVarPath = `/api/v1/products/{product_id}/variants`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				productVariantCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 옵션 삭제
		 * @summary Delete Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantDeleteProductVariant: async (
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists(
				"productVariantDeleteProductVariant",
				"productId",
				productId,
			);
			// verify required parameter 'variantId' is not null or undefined
			assertParamExists(
				"productVariantDeleteProductVariant",
				"variantId",
				variantId,
			);
			const localVarPath = `/api/v1/products/{product_id}/variants/{variant_id}`
				.replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
				.replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 옵션 상세 조회
		 * @summary Read Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantReadProductVariant: async (
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists(
				"productVariantReadProductVariant",
				"productId",
				productId,
			);
			// verify required parameter 'variantId' is not null or undefined
			assertParamExists(
				"productVariantReadProductVariant",
				"variantId",
				variantId,
			);
			const localVarPath = `/api/v1/products/{product_id}/variants/{variant_id}`
				.replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
				.replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 별 옵션 목록 조회
		 * @summary Read Product Variants
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantReadProductVariants: async (
			productId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists(
				"productVariantReadProductVariants",
				"productId",
				productId,
			);
			const localVarPath = `/api/v1/products/{product_id}/variants`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 옵션 수정
		 * @summary Update Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {ProductVariantUpdate} productVariantUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantUpdateProductVariant: async (
			productId: string,
			variantId: string,
			productVariantUpdate: ProductVariantUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists(
				"productVariantUpdateProductVariant",
				"productId",
				productId,
			);
			// verify required parameter 'variantId' is not null or undefined
			assertParamExists(
				"productVariantUpdateProductVariant",
				"variantId",
				variantId,
			);
			// verify required parameter 'productVariantUpdate' is not null or undefined
			assertParamExists(
				"productVariantUpdateProductVariant",
				"productVariantUpdate",
				productVariantUpdate,
			);
			const localVarPath = `/api/v1/products/{product_id}/variants/{variant_id}`
				.replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
				.replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				productVariantUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * ProductVariantApi - functional programming interface
 * @export
 */
export const ProductVariantApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		ProductVariantApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 상품 옵션 생성
		 * @summary Create Product Variant
		 * @param {string} productId
		 * @param {ProductVariantCreate} productVariantCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productVariantCreateProductVariant(
			productId: string,
			productVariantCreate: ProductVariantCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVariant>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productVariantCreateProductVariant(
					productId,
					productVariantCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"ProductVariantApi.productVariantCreateProductVariant"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 옵션 삭제
		 * @summary Delete Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productVariantDeleteProductVariant(
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productVariantDeleteProductVariant(
					productId,
					variantId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"ProductVariantApi.productVariantDeleteProductVariant"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 옵션 상세 조회
		 * @summary Read Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productVariantReadProductVariant(
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVariant>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productVariantReadProductVariant(
					productId,
					variantId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"ProductVariantApi.productVariantReadProductVariant"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 별 옵션 목록 조회
		 * @summary Read Product Variants
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productVariantReadProductVariants(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<ProductVariant>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productVariantReadProductVariants(
					productId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"ProductVariantApi.productVariantReadProductVariants"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 옵션 수정
		 * @summary Update Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {ProductVariantUpdate} productVariantUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async productVariantUpdateProductVariant(
			productId: string,
			variantId: string,
			productVariantUpdate: ProductVariantUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVariant>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.productVariantUpdateProductVariant(
					productId,
					variantId,
					productVariantUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"ProductVariantApi.productVariantUpdateProductVariant"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * ProductVariantApi - factory interface
 * @export
 */
export const ProductVariantApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = ProductVariantApiFp(configuration);
	return {
		/**
		 * 신규 상품 옵션 생성
		 * @summary Create Product Variant
		 * @param {string} productId
		 * @param {ProductVariantCreate} productVariantCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantCreateProductVariant(
			productId: string,
			productVariantCreate: ProductVariantCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ProductVariant> {
			return localVarFp
				.productVariantCreateProductVariant(
					productId,
					productVariantCreate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 옵션 삭제
		 * @summary Delete Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantDeleteProductVariant(
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.productVariantDeleteProductVariant(
					productId,
					variantId,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 옵션 상세 조회
		 * @summary Read Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantReadProductVariant(
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ProductVariant> {
			return localVarFp
				.productVariantReadProductVariant(
					productId,
					variantId,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 별 옵션 목록 조회
		 * @summary Read Product Variants
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantReadProductVariants(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<ProductVariant>> {
			return localVarFp
				.productVariantReadProductVariants(productId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 옵션 수정
		 * @summary Update Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {ProductVariantUpdate} productVariantUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		productVariantUpdateProductVariant(
			productId: string,
			variantId: string,
			productVariantUpdate: ProductVariantUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ProductVariant> {
			return localVarFp
				.productVariantUpdateProductVariant(
					productId,
					variantId,
					productVariantUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * ProductVariantApi - object-oriented interface
 * @export
 * @class ProductVariantApi
 * @extends {BaseAPI}
 */
export class ProductVariantApi extends BaseAPI {
	/**
	 * 신규 상품 옵션 생성
	 * @summary Create Product Variant
	 * @param {string} productId
	 * @param {ProductVariantCreate} productVariantCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductVariantApi
	 */
	public productVariantCreateProductVariant(
		productId: string,
		productVariantCreate: ProductVariantCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductVariantApiFp(this.configuration)
			.productVariantCreateProductVariant(
				productId,
				productVariantCreate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 옵션 삭제
	 * @summary Delete Product Variant
	 * @param {string} productId
	 * @param {string} variantId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductVariantApi
	 */
	public productVariantDeleteProductVariant(
		productId: string,
		variantId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductVariantApiFp(this.configuration)
			.productVariantDeleteProductVariant(
				productId,
				variantId,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 옵션 상세 조회
	 * @summary Read Product Variant
	 * @param {string} productId
	 * @param {string} variantId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductVariantApi
	 */
	public productVariantReadProductVariant(
		productId: string,
		variantId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductVariantApiFp(this.configuration)
			.productVariantReadProductVariant(
				productId,
				variantId,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 별 옵션 목록 조회
	 * @summary Read Product Variants
	 * @param {string} productId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductVariantApi
	 */
	public productVariantReadProductVariants(
		productId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductVariantApiFp(this.configuration)
			.productVariantReadProductVariants(productId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 옵션 수정
	 * @summary Update Product Variant
	 * @param {string} productId
	 * @param {string} variantId
	 * @param {ProductVariantUpdate} productVariantUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProductVariantApi
	 */
	public productVariantUpdateProductVariant(
		productId: string,
		variantId: string,
		productVariantUpdate: ProductVariantUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return ProductVariantApiFp(this.configuration)
			.productVariantUpdateProductVariant(
				productId,
				variantId,
				productVariantUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}
