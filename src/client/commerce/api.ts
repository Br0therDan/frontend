/* tslint:disable */
/* eslint-disable */
/**
 * MySingle Commerce  [dev]
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
	BASE_PATH,
	COLLECTION_FORMATS,
	BaseAPI,
	RequiredError,
	operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface Brand
 */
export interface Brand {
	/**
	 *
	 * @type {string}
	 * @memberof Brand
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Brand
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Brand
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Brand
	 */
	logo_url?: string | null;
}
/**
 *
 * @export
 * @interface Brand1
 */
export interface Brand1 {
	/**
	 *
	 * @type {string}
	 * @memberof Brand1
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof Brand1
	 */
	collection: string;
}
/**
 *
 * @export
 * @interface BrandCreate
 */
export interface BrandCreate {
	/**
	 *
	 * @type {string}
	 * @memberof BrandCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof BrandCreate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof BrandCreate
	 */
	logo_url?: string | null;
}
/**
 * 카테고리 정보 (트리 구조를 위해 parent를 자기참조 가능) created_at/updated_at이 불필요하다고 가정
 * @export
 * @interface Category
 */
export interface Category {
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Category
	 */
	description?: string | null;
	/**
	 *
	 * @type {ParentId}
	 * @memberof Category
	 */
	parent_id?: ParentId | null;
}
/**
 *
 * @export
 * @interface Category1
 */
export interface Category1 {
	/**
	 *
	 * @type {string}
	 * @memberof Category1
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof Category1
	 */
	collection: string;
}
/**
 *
 * @export
 * @interface CategoryCreate
 */
export interface CategoryCreate {
	/**
	 *
	 * @type {string}
	 * @memberof CategoryCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryCreate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryCreate
	 */
	parent_id?: string | null;
}
/**
 *
 * @export
 * @interface CategoryUpdate
 */
export interface CategoryUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof CategoryUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryUpdate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof CategoryUpdate
	 */
	parent_id?: string | null;
}
/**
 *
 * @export
 * @interface ChannelId
 */
export interface ChannelId {
	/**
	 *
	 * @type {string}
	 * @memberof ChannelId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelId
	 */
	collection: string;
}
/**
 * 특정 채널에 등록된 상품옵션. 채널별 가격, SKU, 상태 등
 * @export
 * @interface ChannelListing
 */
export interface ChannelListing {
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	updated_at?: string;
	/**
	 *
	 * @type {ChannelId}
	 * @memberof ChannelListing
	 */
	channel_id: ChannelId;
	/**
	 *
	 * @type {VariantId}
	 * @memberof ChannelListing
	 */
	variant_id: VariantId;
	/**
	 *
	 * @type {number}
	 * @memberof ChannelListing
	 */
	channel_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	external_sku?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListing
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface ChannelListingCreate
 */
export interface ChannelListingCreate {
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingCreate
	 */
	channel_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingCreate
	 */
	variant_id: string;
	/**
	 *
	 * @type {number}
	 * @memberof ChannelListingCreate
	 */
	channel_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingCreate
	 */
	external_sku?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingCreate
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface ChannelListingUpdate
 */
export interface ChannelListingUpdate {
	/**
	 *
	 * @type {number}
	 * @memberof ChannelListingUpdate
	 */
	channel_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingUpdate
	 */
	external_sku?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ChannelListingUpdate
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
	/**
	 *
	 * @type {Array<ValidationError>}
	 * @memberof HTTPValidationError
	 */
	detail?: Array<ValidationError>;
}
/**
 * 단일 옵션(Variant)의 재고 정보를 관리
 * @export
 * @interface Inventory
 */
export interface Inventory {
	/**
	 *
	 * @type {string}
	 * @memberof Inventory
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Inventory
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Inventory
	 */
	updated_at?: string;
	/**
	 *
	 * @type {VariantId}
	 * @memberof Inventory
	 */
	variant_id: VariantId;
	/**
	 *
	 * @type {number}
	 * @memberof Inventory
	 */
	stock?: number;
	/**
	 *
	 * @type {number}
	 * @memberof Inventory
	 */
	average_cost?: number | null;
}
/**
 *
 * @export
 * @interface InventoryCreate
 */
export interface InventoryCreate {
	/**
	 *
	 * @type {string}
	 * @memberof InventoryCreate
	 */
	variant_id: string;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryCreate
	 */
	stock?: number;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryCreate
	 */
	average_cost?: number | null;
}
/**
 *
 * @export
 * @interface InventoryId
 */
export interface InventoryId {
	/**
	 *
	 * @type {string}
	 * @memberof InventoryId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryId
	 */
	collection: string;
}
/**
 * 재고 변동 이력 (입고, 출고, 반품 등)
 * @export
 * @interface InventoryTransaction
 */
export interface InventoryTransaction {
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	updated_at?: string;
	/**
	 *
	 * @type {InventoryId}
	 * @memberof InventoryTransaction
	 */
	inventory_id: InventoryId;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryTransaction
	 */
	quantity_change: number;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	reason?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryTransaction
	 */
	cost_per_unit?: number | null;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransaction
	 */
	transaction_at?: string;
}
/**
 *
 * @export
 * @interface InventoryTransactionRequest
 */
export interface InventoryTransactionRequest {
	/**
	 *
	 * @type {number}
	 * @memberof InventoryTransactionRequest
	 */
	quantity_change: number;
	/**
	 *
	 * @type {string}
	 * @memberof InventoryTransactionRequest
	 */
	reason?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryTransactionRequest
	 */
	cost_per_unit?: number | null;
}
/**
 *
 * @export
 * @interface InventoryUpdate
 */
export interface InventoryUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof InventoryUpdate
	 */
	variant_id?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryUpdate
	 */
	stock?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof InventoryUpdate
	 */
	average_cost?: number | null;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
	/**
	 *
	 * @type {string}
	 * @memberof Message
	 */
	message: string;
}
/**
 * 여러 채널에서 들어온 주문을 통합 관리
 * @export
 * @interface Order
 */
export interface Order {
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	_id?: string | null;
	/**
	 *
	 * @type {ChannelId}
	 * @memberof Order
	 */
	channel_id: ChannelId;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	external_order_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	order_date?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	order_status?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Order
	 */
	customer_id?: string | null;
}
/**
 *
 * @export
 * @interface OrderCreate
 */
export interface OrderCreate {
	/**
	 *
	 * @type {string}
	 * @memberof OrderCreate
	 */
	channel_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderCreate
	 */
	external_order_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderCreate
	 */
	order_status?: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderCreate
	 */
	customer_id: string;
}
/**
 *
 * @export
 * @interface OrderId
 */
export interface OrderId {
	/**
	 *
	 * @type {string}
	 * @memberof OrderId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderId
	 */
	collection: string;
}
/**
 * 주문 상세항목 (하나의 주문에 여러 상품옵션 가능)
 * @export
 * @interface OrderLineItem
 */
export interface OrderLineItem {
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItem
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItem
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItem
	 */
	updated_at?: string;
	/**
	 *
	 * @type {OrderId}
	 * @memberof OrderLineItem
	 */
	order_id: OrderId;
	/**
	 *
	 * @type {VariantId}
	 * @memberof OrderLineItem
	 */
	variant_id: VariantId;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItem
	 */
	quantity: number;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItem
	 */
	unit_price: number;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItem
	 */
	total_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItem
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface OrderLineItemCreate
 */
export interface OrderLineItemCreate {
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemCreate
	 */
	order_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemCreate
	 */
	variant_id: string;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemCreate
	 */
	quantity: number;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemCreate
	 */
	unit_price: number;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemCreate
	 */
	total_price: number;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemCreate
	 */
	status?: string;
}
/**
 *
 * @export
 * @interface OrderLineItemUpdate
 */
export interface OrderLineItemUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemUpdate
	 */
	order_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemUpdate
	 */
	variant_id?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemUpdate
	 */
	quantity?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemUpdate
	 */
	unit_price?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof OrderLineItemUpdate
	 */
	total_price?: number | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderLineItemUpdate
	 */
	status?: string | null;
}
/**
 *
 * @export
 * @interface OrderUpdate
 */
export interface OrderUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof OrderUpdate
	 */
	channel_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderUpdate
	 */
	external_order_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof OrderUpdate
	 */
	order_status?: string | null;
}
/**
 *
 * @export
 * @interface ParentId
 */
export interface ParentId {
	/**
	 *
	 * @type {string}
	 * @memberof ParentId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ParentId
	 */
	collection: string;
}
/**
 *
 * @export
 * @interface ParentIdAnyOf
 */
export interface ParentIdAnyOf {
	/**
	 *
	 * @type {string}
	 * @memberof ParentIdAnyOf
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ParentIdAnyOf
	 */
	collection: string;
}
/**
 * 상품 상위 정보 (타임스탬프 추적)
 * @export
 * @interface Product
 */
export interface Product {
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	updated_at?: string;
	/**
	 *
	 * @type {Brand1}
	 * @memberof Product
	 */
	brand?: Brand1 | null;
	/**
	 *
	 * @type {Category1}
	 * @memberof Product
	 */
	category?: Category1 | null;
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Product
	 */
	description?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof Product
	 */
	base_price?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof Product
	 */
	is_active?: boolean;
	/**
	 *
	 * @type {Array<ProductVariantsInner>}
	 * @memberof Product
	 */
	variants?: Array<ProductVariantsInner>;
}
/**
 *
 * @export
 * @interface ProductCreate
 */
export interface ProductCreate {
	/**
	 *
	 * @type {string}
	 * @memberof ProductCreate
	 */
	brand_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductCreate
	 */
	category_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductCreate
	 */
	description?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductCreate
	 */
	base_price?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductCreate
	 */
	is_active?: boolean;
}
/**
 *
 * @export
 * @interface ProductUpdate
 */
export interface ProductUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof ProductUpdate
	 */
	brand_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductUpdate
	 */
	category_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductUpdate
	 */
	description?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductUpdate
	 */
	base_price?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductUpdate
	 */
	is_active: boolean | null;
}
/**
 * 상품 옵션(색상, 사이즈, SKU 등)
 * @export
 * @interface ProductVariant
 */
export interface ProductVariant {
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	updated_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	product_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariant
	 */
	sku?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariant
	 */
	option_price?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariant
	 */
	option_cost?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductVariant
	 */
	is_active?: boolean;
}
/**
 *
 * @export
 * @interface ProductVariantCreate
 */
export interface ProductVariantCreate {
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantCreate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantCreate
	 */
	sku?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariantCreate
	 */
	option_price?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariantCreate
	 */
	option_cost?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductVariantCreate
	 */
	is_active?: boolean;
}
/**
 *
 * @export
 * @interface ProductVariantUpdate
 */
export interface ProductVariantUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantUpdate
	 */
	sku?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariantUpdate
	 */
	option_price?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof ProductVariantUpdate
	 */
	option_cost?: number | null;
	/**
	 *
	 * @type {boolean}
	 * @memberof ProductVariantUpdate
	 */
	is_active?: boolean | null;
}
/**
 *
 * @export
 * @interface ProductVariantsInner
 */
export interface ProductVariantsInner {
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantsInner
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof ProductVariantsInner
	 */
	collection: string;
}
/**
 * 예) 자사몰, 쿠팡, Qoo10 등
 * @export
 * @interface SalesChannel
 */
export interface SalesChannel {
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannel
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannel
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannel
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannel
	 */
	channel_code?: string | null;
}
/**
 *
 * @export
 * @interface SalesChannelCreate
 */
export interface SalesChannelCreate {
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelCreate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelCreate
	 */
	channel_code?: string | null;
}
/**
 *
 * @export
 * @interface SalesChannelUpdate
 */
export interface SalesChannelUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelUpdate
	 */
	description?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof SalesChannelUpdate
	 */
	channel_code?: string | null;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
	/**
	 *
	 * @type {Array<ValidationErrorLocInner>}
	 * @memberof ValidationError
	 */
	loc: Array<ValidationErrorLocInner>;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	msg: string;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	type: string;
}
/**
 *
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {}
/**
 *
 * @export
 * @interface VariantId
 */
export interface VariantId {
	/**
	 *
	 * @type {string}
	 * @memberof VariantId
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof VariantId
	 */
	collection: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 신규 브랜드 생성 - 사용자가 소유한 브랜드 중 동일한 이름이 있는지 검사
		 * @summary Create Brand
		 * @param {BrandCreate} brandCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createBrand: async (
			brandCreate: BrandCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'brandCreate' is not null or undefined
			assertParamExists("createBrand", "brandCreate", brandCreate);
			const localVarPath = `/api/v1/brands/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				brandCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 신규 카테고리 생성 - 사용자가 소유한 카테고리 중 동일한 이름이 있는지 검사 - 부모 카테고리(parent_id)가 있다면, 해당 카테고리가 존재하고 현재 사용자가 소유한 카테고리여야 함
		 * @summary Create Category
		 * @param {CategoryCreate} categoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createCategory: async (
			categoryCreate: CategoryCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryCreate' is not null or undefined
			assertParamExists("createCategory", "categoryCreate", categoryCreate);
			const localVarPath = `/api/v1/categories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				categoryCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 신규 채널 생성
		 * @summary Create Channel
		 * @param {SalesChannelCreate} salesChannelCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createChannel: async (
			salesChannelCreate: SalesChannelCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'salesChannelCreate' is not null or undefined
			assertParamExists(
				"createChannel",
				"salesChannelCreate",
				salesChannelCreate,
			);
			const localVarPath = `/api/v1/channels/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				salesChannelCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 신규 채널 리스팅 생성
		 * @summary Create Channel Listing
		 * @param {ChannelListingCreate} channelListingCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createChannelListing: async (
			channelListingCreate: ChannelListingCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelListingCreate' is not null or undefined
			assertParamExists(
				"createChannelListing",
				"channelListingCreate",
				channelListingCreate,
			);
			const localVarPath = `/api/v1/listings/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				channelListingCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 신규 인벤토리 생성
		 * @summary Create Inventory
		 * @param {InventoryCreate} inventoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createInventory: async (
			inventoryCreate: InventoryCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryCreate' is not null or undefined
			assertParamExists("createInventory", "inventoryCreate", inventoryCreate);
			const localVarPath = `/api/v1/inventories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				inventoryCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 신규 재고 생성
		 * @summary Create Invetory Transaction
		 * @param {string} inventoryId
		 * @param {InventoryTransactionRequest} inventoryTransactionRequest
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createInvetoryTransaction: async (
			inventoryId: string,
			inventoryTransactionRequest: InventoryTransactionRequest,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists(
				"createInvetoryTransaction",
				"inventoryId",
				inventoryId,
			);
			// verify required parameter 'inventoryTransactionRequest' is not null or undefined
			assertParamExists(
				"createInvetoryTransaction",
				"inventoryTransactionRequest",
				inventoryTransactionRequest,
			);
			const localVarPath =
				`/api/v1/inventories/{inventory_id}/transactions`.replace(
					`{${"inventory_id"}}`,
					encodeURIComponent(String(inventoryId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				inventoryTransactionRequest,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 신규 주문 생성
		 * @summary Create Order
		 * @param {OrderCreate} orderCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOrder: async (
			orderCreate: OrderCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderCreate' is not null or undefined
			assertParamExists("createOrder", "orderCreate", orderCreate);
			const localVarPath = `/api/v1/orders/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				orderCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문에 상품 추가
		 * @summary Create Order Line Item
		 * @param {string} orderId
		 * @param {OrderLineItemCreate} orderLineItemCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOrderLineItem: async (
			orderId: string,
			orderLineItemCreate: OrderLineItemCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("createOrderLineItem", "orderId", orderId);
			// verify required parameter 'orderLineItemCreate' is not null or undefined
			assertParamExists(
				"createOrderLineItem",
				"orderLineItemCreate",
				orderLineItemCreate,
			);
			const localVarPath = `/api/v1/orders/{order_id}/line-items`.replace(
				`{${"order_id"}}`,
				encodeURIComponent(String(orderId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				orderLineItemCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 신규 상품 생성 - 사용자가 소유한 상품 중 동일한 이름이 있는지 검사
		 * @summary Create Product
		 * @param {ProductCreate} productCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createProduct: async (
			productCreate: ProductCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productCreate' is not null or undefined
			assertParamExists("createProduct", "productCreate", productCreate);
			const localVarPath = `/api/v1/products/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				productCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 신규 상품 옵션 생성
		 * @summary Create Product Variant
		 * @param {string} productId
		 * @param {ProductVariantCreate} productVariantCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createProductVariant: async (
			productId: string,
			productVariantCreate: ProductVariantCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("createProductVariant", "productId", productId);
			// verify required parameter 'productVariantCreate' is not null or undefined
			assertParamExists(
				"createProductVariant",
				"productVariantCreate",
				productVariantCreate,
			);
			const localVarPath = `/api/v1/products/{product_id}/variants`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				productVariantCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 브랜드 삭제
		 * @summary Delete Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteBrand: async (
			brandId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'brandId' is not null or undefined
			assertParamExists("deleteBrand", "brandId", brandId);
			const localVarPath = `/api/v1/brands/{brand_id}`.replace(
				`{${"brand_id"}}`,
				encodeURIComponent(String(brandId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 카테고리 삭제
		 * @summary Delete Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteCategory: async (
			categoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists("deleteCategory", "categoryId", categoryId);
			const localVarPath = `/api/v1/categories/{category_id}`.replace(
				`{${"category_id"}}`,
				encodeURIComponent(String(categoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 삭제
		 * @summary Delete Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteChannel: async (
			channelId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelId' is not null or undefined
			assertParamExists("deleteChannel", "channelId", channelId);
			const localVarPath = `/api/v1/channels/{channel_id}`.replace(
				`{${"channel_id"}}`,
				encodeURIComponent(String(channelId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 리스팅 삭제
		 * @summary Delete Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteChannelListing: async (
			channelListingId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelListingId' is not null or undefined
			assertParamExists(
				"deleteChannelListing",
				"channelListingId",
				channelListingId,
			);
			const localVarPath = `/api/v1/listings/{channel_listing_id}`.replace(
				`{${"channel_listing_id"}}`,
				encodeURIComponent(String(channelListingId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 인벤토리 삭제
		 * @summary Delete Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteInventory: async (
			inventoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists("deleteInventory", "inventoryId", inventoryId);
			const localVarPath = `/api/v1/inventories/{inventory_id}`.replace(
				`{${"inventory_id"}}`,
				encodeURIComponent(String(inventoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문의 상품 삭제
		 * @summary Delete Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOrderLineItem: async (
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("deleteOrderLineItem", "orderId", orderId);
			// verify required parameter 'lineItemId' is not null or undefined
			assertParamExists("deleteOrderLineItem", "lineItemId", lineItemId);
			const localVarPath = `/api/v1/orders/{order_id}/line-items/{line_item_id}`
				.replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
				.replace(`{${"line_item_id"}}`, encodeURIComponent(String(lineItemId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 삭제
		 * @summary Delete Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteProduct: async (
			productId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("deleteProduct", "productId", productId);
			const localVarPath = `/api/v1/products/{product_id}`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 옵션 삭제
		 * @summary Delete Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteProductVariant: async (
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("deleteProductVariant", "productId", productId);
			// verify required parameter 'variantId' is not null or undefined
			assertParamExists("deleteProductVariant", "variantId", variantId);
			const localVarPath = `/api/v1/products/{product_id}/variants/{variant_id}`
				.replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
				.replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 브랜드 상세 조회
		 * @summary Read Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readBrand: async (
			brandId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'brandId' is not null or undefined
			assertParamExists("readBrand", "brandId", brandId);
			const localVarPath = `/api/v1/brands/{brand_id}`.replace(
				`{${"brand_id"}}`,
				encodeURIComponent(String(brandId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 브랜드 목록 조회
		 * @summary Read Brands
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readBrands: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/brands/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 카테고리 목록 조회
		 * @summary Read Categories
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readCategories: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/categories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 카테고리 상세 조회
		 * @summary Read Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readCategory: async (
			categoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists("readCategory", "categoryId", categoryId);
			const localVarPath = `/api/v1/categories/{category_id}`.replace(
				`{${"category_id"}}`,
				encodeURIComponent(String(categoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 상세 조회
		 * @summary Read Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readChannel: async (
			channelId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelId' is not null or undefined
			assertParamExists("readChannel", "channelId", channelId);
			const localVarPath = `/api/v1/channels/{channel_id}`.replace(
				`{${"channel_id"}}`,
				encodeURIComponent(String(channelId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 리스팅 상세 조회
		 * @summary Read Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readChannelListing: async (
			channelListingId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelListingId' is not null or undefined
			assertParamExists(
				"readChannelListing",
				"channelListingId",
				channelListingId,
			);
			const localVarPath = `/api/v1/listings/{channel_listing_id}`.replace(
				`{${"channel_listing_id"}}`,
				encodeURIComponent(String(channelListingId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 리스팅 목록 조회
		 * @summary Read Channel Listings
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readChannelListings: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/listings/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 목록 조회
		 * @summary Read Channels
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readChannels: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/channels/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 인벤토리 목록 조회
		 * @summary Read Inventories
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readInventories: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/inventories/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 인벤토리 조회
		 * @summary Read Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readInventory: async (
			inventoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists("readInventory", "inventoryId", inventoryId);
			const localVarPath = `/api/v1/inventories/{inventory_id}`.replace(
				`{${"inventory_id"}}`,
				encodeURIComponent(String(inventoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 재고 거래 내역 상세 조회
		 * @summary Read Inventory Transaction
		 * @param {string} inventoryId
		 * @param {string} transactionId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readInventoryTransaction: async (
			inventoryId: string,
			transactionId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists("readInventoryTransaction", "inventoryId", inventoryId);
			// verify required parameter 'transactionId' is not null or undefined
			assertParamExists(
				"readInventoryTransaction",
				"transactionId",
				transactionId,
			);
			const localVarPath =
				`/api/v1/inventories/{inventory_id}/transactions/{transaction_id}`
					.replace(
						`{${"inventory_id"}}`,
						encodeURIComponent(String(inventoryId)),
					)
					.replace(
						`{${"transaction_id"}}`,
						encodeURIComponent(String(transactionId)),
					);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 재고 거래 내역 조회
		 * @summary Read Inventory Transactions
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readInventoryTransactions: async (
			inventoryId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists(
				"readInventoryTransactions",
				"inventoryId",
				inventoryId,
			);
			const localVarPath =
				`/api/v1/inventories/{inventory_id}/transactions`.replace(
					`{${"inventory_id"}}`,
					encodeURIComponent(String(inventoryId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문 상세 조회
		 * @summary Read Order
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readOrder: async (
			orderId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("readOrder", "orderId", orderId);
			const localVarPath = `/api/v1/orders/{order_id}`.replace(
				`{${"order_id"}}`,
				encodeURIComponent(String(orderId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문의 상품 상세 조회
		 * @summary Read Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readOrderLineItem: async (
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("readOrderLineItem", "orderId", orderId);
			// verify required parameter 'lineItemId' is not null or undefined
			assertParamExists("readOrderLineItem", "lineItemId", lineItemId);
			const localVarPath = `/api/v1/orders/{order_id}/line-items/{line_item_id}`
				.replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
				.replace(`{${"line_item_id"}}`, encodeURIComponent(String(lineItemId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문의 상품 목록 조회
		 * @summary Read Order Line Items
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readOrderLineItems: async (
			orderId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("readOrderLineItems", "orderId", orderId);
			const localVarPath = `/api/v1/orders/{order_id}/line-items`.replace(
				`{${"order_id"}}`,
				encodeURIComponent(String(orderId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문 목록 조회
		 * @summary Read Orders
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readOrders: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/orders/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 상세 조회
		 * @summary Read Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readProduct: async (
			productId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("readProduct", "productId", productId);
			const localVarPath = `/api/v1/products/{product_id}`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 옵션 상세 조회
		 * @summary Read Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readProductVariant: async (
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("readProductVariant", "productId", productId);
			// verify required parameter 'variantId' is not null or undefined
			assertParamExists("readProductVariant", "variantId", variantId);
			const localVarPath = `/api/v1/products/{product_id}/variants/{variant_id}`
				.replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
				.replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 별 옵션 목록 조회
		 * @summary Read Product Variants
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readProductVariants: async (
			productId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("readProductVariants", "productId", productId);
			const localVarPath = `/api/v1/products/{product_id}/variants`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 목록 조회
		 * @summary Read Products
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readProducts: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/products/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 브랜드 수정
		 * @summary Update Brand
		 * @param {string} brandId
		 * @param {BrandCreate} brandCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateBrand: async (
			brandId: string,
			brandCreate: BrandCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'brandId' is not null or undefined
			assertParamExists("updateBrand", "brandId", brandId);
			// verify required parameter 'brandCreate' is not null or undefined
			assertParamExists("updateBrand", "brandCreate", brandCreate);
			const localVarPath = `/api/v1/brands/{brand_id}`.replace(
				`{${"brand_id"}}`,
				encodeURIComponent(String(brandId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				brandCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 카테고리 수정
		 * @summary Update Category
		 * @param {string} categoryId
		 * @param {CategoryUpdate} categoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateCategory: async (
			categoryId: string,
			categoryUpdate: CategoryUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'categoryId' is not null or undefined
			assertParamExists("updateCategory", "categoryId", categoryId);
			// verify required parameter 'categoryUpdate' is not null or undefined
			assertParamExists("updateCategory", "categoryUpdate", categoryUpdate);
			const localVarPath = `/api/v1/categories/{category_id}`.replace(
				`{${"category_id"}}`,
				encodeURIComponent(String(categoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				categoryUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 수정
		 * @summary Update Channel
		 * @param {string} channelId
		 * @param {SalesChannelUpdate} salesChannelUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateChannel: async (
			channelId: string,
			salesChannelUpdate: SalesChannelUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelId' is not null or undefined
			assertParamExists("updateChannel", "channelId", channelId);
			// verify required parameter 'salesChannelUpdate' is not null or undefined
			assertParamExists(
				"updateChannel",
				"salesChannelUpdate",
				salesChannelUpdate,
			);
			const localVarPath = `/api/v1/channels/{channel_id}`.replace(
				`{${"channel_id"}}`,
				encodeURIComponent(String(channelId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				salesChannelUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 채널 리스팅 정보 수정
		 * @summary Update Channel Listing
		 * @param {string} channelListingId
		 * @param {ChannelListingUpdate} channelListingUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateChannelListing: async (
			channelListingId: string,
			channelListingUpdate: ChannelListingUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'channelListingId' is not null or undefined
			assertParamExists(
				"updateChannelListing",
				"channelListingId",
				channelListingId,
			);
			// verify required parameter 'channelListingUpdate' is not null or undefined
			assertParamExists(
				"updateChannelListing",
				"channelListingUpdate",
				channelListingUpdate,
			);
			const localVarPath = `/api/v1/listings/{channel_listing_id}`.replace(
				`{${"channel_listing_id"}}`,
				encodeURIComponent(String(channelListingId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				channelListingUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 인벤토리 정보 수정
		 * @summary Update Inventory
		 * @param {string} inventoryId
		 * @param {InventoryUpdate} inventoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateInventory: async (
			inventoryId: string,
			inventoryUpdate: InventoryUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'inventoryId' is not null or undefined
			assertParamExists("updateInventory", "inventoryId", inventoryId);
			// verify required parameter 'inventoryUpdate' is not null or undefined
			assertParamExists("updateInventory", "inventoryUpdate", inventoryUpdate);
			const localVarPath = `/api/v1/inventories/{inventory_id}`.replace(
				`{${"inventory_id"}}`,
				encodeURIComponent(String(inventoryId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				inventoryUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문 수정
		 * @summary Update Order
		 * @param {string} orderId
		 * @param {OrderUpdate} orderUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOrder: async (
			orderId: string,
			orderUpdate: OrderUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("updateOrder", "orderId", orderId);
			// verify required parameter 'orderUpdate' is not null or undefined
			assertParamExists("updateOrder", "orderUpdate", orderUpdate);
			const localVarPath = `/api/v1/orders/{order_id}`.replace(
				`{${"order_id"}}`,
				encodeURIComponent(String(orderId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				orderUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 주문의 상품 수정
		 * @summary Update Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {OrderLineItemUpdate} orderLineItemUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOrderLineItem: async (
			orderId: string,
			lineItemId: string,
			orderLineItemUpdate: OrderLineItemUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'orderId' is not null or undefined
			assertParamExists("updateOrderLineItem", "orderId", orderId);
			// verify required parameter 'lineItemId' is not null or undefined
			assertParamExists("updateOrderLineItem", "lineItemId", lineItemId);
			// verify required parameter 'orderLineItemUpdate' is not null or undefined
			assertParamExists(
				"updateOrderLineItem",
				"orderLineItemUpdate",
				orderLineItemUpdate,
			);
			const localVarPath = `/api/v1/orders/{order_id}/line-items/{line_item_id}`
				.replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)))
				.replace(`{${"line_item_id"}}`, encodeURIComponent(String(lineItemId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				orderLineItemUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 수정
		 * @summary Update Product
		 * @param {string} productId
		 * @param {ProductUpdate} productUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateProduct: async (
			productId: string,
			productUpdate: ProductUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("updateProduct", "productId", productId);
			// verify required parameter 'productUpdate' is not null or undefined
			assertParamExists("updateProduct", "productUpdate", productUpdate);
			const localVarPath = `/api/v1/products/{product_id}`.replace(
				`{${"product_id"}}`,
				encodeURIComponent(String(productId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				productUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 상품 옵션 수정
		 * @summary Update Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {ProductVariantUpdate} productVariantUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateProductVariant: async (
			productId: string,
			variantId: string,
			productVariantUpdate: ProductVariantUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'productId' is not null or undefined
			assertParamExists("updateProductVariant", "productId", productId);
			// verify required parameter 'variantId' is not null or undefined
			assertParamExists("updateProductVariant", "variantId", variantId);
			// verify required parameter 'productVariantUpdate' is not null or undefined
			assertParamExists(
				"updateProductVariant",
				"productVariantUpdate",
				productVariantUpdate,
			);
			const localVarPath = `/api/v1/products/{product_id}/variants/{variant_id}`
				.replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
				.replace(`{${"variant_id"}}`, encodeURIComponent(String(variantId)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PATCH",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				productVariantUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
	return {
		/**
		 * 신규 브랜드 생성 - 사용자가 소유한 브랜드 중 동일한 이름이 있는지 검사
		 * @summary Create Brand
		 * @param {BrandCreate} brandCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createBrand(
			brandCreate: BrandCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brand>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createBrand(
				brandCreate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createBrand"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 신규 카테고리 생성 - 사용자가 소유한 카테고리 중 동일한 이름이 있는지 검사 - 부모 카테고리(parent_id)가 있다면, 해당 카테고리가 존재하고 현재 사용자가 소유한 카테고리여야 함
		 * @summary Create Category
		 * @param {CategoryCreate} categoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createCategory(
			categoryCreate: CategoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(
				categoryCreate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 신규 채널 생성
		 * @summary Create Channel
		 * @param {SalesChannelCreate} salesChannelCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createChannel(
			salesChannelCreate: SalesChannelCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SalesChannel>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createChannel(
				salesChannelCreate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createChannel"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 신규 채널 리스팅 생성
		 * @summary Create Channel Listing
		 * @param {ChannelListingCreate} channelListingCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createChannelListing(
			channelListingCreate: ChannelListingCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelListing>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.createChannelListing(
					channelListingCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createChannelListing"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 신규 인벤토리 생성
		 * @summary Create Inventory
		 * @param {InventoryCreate} inventoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createInventory(
			inventoryCreate: InventoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inventory>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createInventory(
				inventoryCreate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createInventory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 신규 재고 생성
		 * @summary Create Invetory Transaction
		 * @param {string} inventoryId
		 * @param {InventoryTransactionRequest} inventoryTransactionRequest
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createInvetoryTransaction(
			inventoryId: string,
			inventoryTransactionRequest: InventoryTransactionRequest,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<InventoryTransaction>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.createInvetoryTransaction(
					inventoryId,
					inventoryTransactionRequest,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createInvetoryTransaction"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 신규 주문 생성
		 * @summary Create Order
		 * @param {OrderCreate} orderCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createOrder(
			orderCreate: OrderCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(
				orderCreate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createOrder"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문에 상품 추가
		 * @summary Create Order Line Item
		 * @param {string} orderId
		 * @param {OrderLineItemCreate} orderLineItemCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createOrderLineItem(
			orderId: string,
			orderLineItemCreate: OrderLineItemCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderLineItem>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.createOrderLineItem(
					orderId,
					orderLineItemCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createOrderLineItem"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 신규 상품 생성 - 사용자가 소유한 상품 중 동일한 이름이 있는지 검사
		 * @summary Create Product
		 * @param {ProductCreate} productCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createProduct(
			productCreate: ProductCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(
				productCreate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createProduct"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 신규 상품 옵션 생성
		 * @summary Create Product Variant
		 * @param {string} productId
		 * @param {ProductVariantCreate} productVariantCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createProductVariant(
			productId: string,
			productVariantCreate: ProductVariantCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVariant>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.createProductVariant(
					productId,
					productVariantCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.createProductVariant"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 브랜드 삭제
		 * @summary Delete Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteBrand(
			brandId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBrand(
				brandId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.deleteBrand"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 카테고리 삭제
		 * @summary Delete Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(
				categoryId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.deleteCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 삭제
		 * @summary Delete Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteChannel(
			channelId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChannel(
				channelId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.deleteChannel"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 리스팅 삭제
		 * @summary Delete Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteChannelListing(
			channelListingId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.deleteChannelListing(
					channelListingId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.deleteChannelListing"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 인벤토리 삭제
		 * @summary Delete Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteInventory(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInventory(
				inventoryId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.deleteInventory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문의 상품 삭제
		 * @summary Delete Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteOrderLineItem(
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.deleteOrderLineItem(
					orderId,
					lineItemId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.deleteOrderLineItem"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 삭제
		 * @summary Delete Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteProduct(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProduct(
				productId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.deleteProduct"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 옵션 삭제
		 * @summary Delete Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteProductVariant(
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.deleteProductVariant(
					productId,
					variantId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.deleteProductVariant"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 브랜드 상세 조회
		 * @summary Read Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readBrand(
			brandId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brand>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readBrand(
				brandId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readBrand"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 브랜드 목록 조회
		 * @summary Read Brands
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readBrands(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Brand>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readBrands(
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readBrands"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 카테고리 목록 조회
		 * @summary Read Categories
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readCategories(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<Category>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readCategories(
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readCategories"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 카테고리 상세 조회
		 * @summary Read Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readCategory(
				categoryId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 상세 조회
		 * @summary Read Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readChannel(
			channelId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SalesChannel>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readChannel(
				channelId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readChannel"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 리스팅 상세 조회
		 * @summary Read Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readChannelListing(
			channelListingId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelListing>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.readChannelListing(
					channelListingId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readChannelListing"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 리스팅 목록 조회
		 * @summary Read Channel Listings
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readChannelListings(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<ChannelListing>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.readChannelListings(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readChannelListings"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 목록 조회
		 * @summary Read Channels
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readChannels(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<SalesChannel>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readChannels(
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readChannels"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 인벤토리 목록 조회
		 * @summary Read Inventories
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readInventories(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<Inventory>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readInventories(
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readInventories"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 인벤토리 조회
		 * @summary Read Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readInventory(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inventory>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readInventory(
				inventoryId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readInventory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 재고 거래 내역 상세 조회
		 * @summary Read Inventory Transaction
		 * @param {string} inventoryId
		 * @param {string} transactionId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readInventoryTransaction(
			inventoryId: string,
			transactionId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<InventoryTransaction>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.readInventoryTransaction(
					inventoryId,
					transactionId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readInventoryTransaction"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 재고 거래 내역 조회
		 * @summary Read Inventory Transactions
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readInventoryTransactions(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<InventoryTransaction>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.readInventoryTransactions(
					inventoryId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readInventoryTransactions"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문 상세 조회
		 * @summary Read Order
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readOrder(
			orderId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readOrder(
				orderId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readOrder"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문의 상품 상세 조회
		 * @summary Read Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readOrderLineItem(
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderLineItem>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.readOrderLineItem(
					orderId,
					lineItemId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readOrderLineItem"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문의 상품 목록 조회
		 * @summary Read Order Line Items
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readOrderLineItems(
			orderId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<OrderLineItem>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.readOrderLineItems(
					orderId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readOrderLineItems"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문 목록 조회
		 * @summary Read Orders
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readOrders(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readOrders(
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readOrders"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 상세 조회
		 * @summary Read Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readProduct(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readProduct(
				productId,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readProduct"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 옵션 상세 조회
		 * @summary Read Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readProductVariant(
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVariant>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.readProductVariant(
					productId,
					variantId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readProductVariant"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 별 옵션 목록 조회
		 * @summary Read Product Variants
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readProductVariants(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<ProductVariant>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.readProductVariants(
					productId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readProductVariants"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 목록 조회
		 * @summary Read Products
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async readProducts(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.readProducts(
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.readProducts"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 브랜드 수정
		 * @summary Update Brand
		 * @param {string} brandId
		 * @param {BrandCreate} brandCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateBrand(
			brandId: string,
			brandCreate: BrandCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Brand>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateBrand(
				brandId,
				brandCreate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.updateBrand"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 카테고리 수정
		 * @summary Update Category
		 * @param {string} categoryId
		 * @param {CategoryUpdate} categoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateCategory(
			categoryId: string,
			categoryUpdate: CategoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(
				categoryId,
				categoryUpdate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.updateCategory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 수정
		 * @summary Update Channel
		 * @param {string} channelId
		 * @param {SalesChannelUpdate} salesChannelUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateChannel(
			channelId: string,
			salesChannelUpdate: SalesChannelUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SalesChannel>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateChannel(
				channelId,
				salesChannelUpdate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.updateChannel"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 채널 리스팅 정보 수정
		 * @summary Update Channel Listing
		 * @param {string} channelListingId
		 * @param {ChannelListingUpdate} channelListingUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateChannelListing(
			channelListingId: string,
			channelListingUpdate: ChannelListingUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelListing>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.updateChannelListing(
					channelListingId,
					channelListingUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.updateChannelListing"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 인벤토리 정보 수정
		 * @summary Update Inventory
		 * @param {string} inventoryId
		 * @param {InventoryUpdate} inventoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateInventory(
			inventoryId: string,
			inventoryUpdate: InventoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Inventory>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateInventory(
				inventoryId,
				inventoryUpdate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.updateInventory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문 수정
		 * @summary Update Order
		 * @param {string} orderId
		 * @param {OrderUpdate} orderUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateOrder(
			orderId: string,
			orderUpdate: OrderUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(
				orderId,
				orderUpdate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.updateOrder"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 주문의 상품 수정
		 * @summary Update Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {OrderLineItemUpdate} orderLineItemUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateOrderLineItem(
			orderId: string,
			lineItemId: string,
			orderLineItemUpdate: OrderLineItemUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderLineItem>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.updateOrderLineItem(
					orderId,
					lineItemId,
					orderLineItemUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.updateOrderLineItem"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 수정
		 * @summary Update Product
		 * @param {string} productId
		 * @param {ProductUpdate} productUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateProduct(
			productId: string,
			productUpdate: ProductUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(
				productId,
				productUpdate,
				accessToken,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.updateProduct"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 상품 옵션 수정
		 * @summary Update Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {ProductVariantUpdate} productVariantUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateProductVariant(
			productId: string,
			variantId: string,
			productVariantUpdate: ProductVariantUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductVariant>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.updateProductVariant(
					productId,
					variantId,
					productVariantUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["DefaultApi.updateProductVariant"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = DefaultApiFp(configuration);
	return {
		/**
		 * 신규 브랜드 생성 - 사용자가 소유한 브랜드 중 동일한 이름이 있는지 검사
		 * @summary Create Brand
		 * @param {BrandCreate} brandCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createBrand(
			brandCreate: BrandCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Brand> {
			return localVarFp
				.createBrand(brandCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 신규 카테고리 생성 - 사용자가 소유한 카테고리 중 동일한 이름이 있는지 검사 - 부모 카테고리(parent_id)가 있다면, 해당 카테고리가 존재하고 현재 사용자가 소유한 카테고리여야 함
		 * @summary Create Category
		 * @param {CategoryCreate} categoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createCategory(
			categoryCreate: CategoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Category> {
			return localVarFp
				.createCategory(categoryCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 신규 채널 생성
		 * @summary Create Channel
		 * @param {SalesChannelCreate} salesChannelCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createChannel(
			salesChannelCreate: SalesChannelCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<SalesChannel> {
			return localVarFp
				.createChannel(salesChannelCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 신규 채널 리스팅 생성
		 * @summary Create Channel Listing
		 * @param {ChannelListingCreate} channelListingCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createChannelListing(
			channelListingCreate: ChannelListingCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ChannelListing> {
			return localVarFp
				.createChannelListing(channelListingCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 신규 인벤토리 생성
		 * @summary Create Inventory
		 * @param {InventoryCreate} inventoryCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createInventory(
			inventoryCreate: InventoryCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Inventory> {
			return localVarFp
				.createInventory(inventoryCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 신규 재고 생성
		 * @summary Create Invetory Transaction
		 * @param {string} inventoryId
		 * @param {InventoryTransactionRequest} inventoryTransactionRequest
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createInvetoryTransaction(
			inventoryId: string,
			inventoryTransactionRequest: InventoryTransactionRequest,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<InventoryTransaction> {
			return localVarFp
				.createInvetoryTransaction(
					inventoryId,
					inventoryTransactionRequest,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 신규 주문 생성
		 * @summary Create Order
		 * @param {OrderCreate} orderCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOrder(
			orderCreate: OrderCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Order> {
			return localVarFp
				.createOrder(orderCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문에 상품 추가
		 * @summary Create Order Line Item
		 * @param {string} orderId
		 * @param {OrderLineItemCreate} orderLineItemCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createOrderLineItem(
			orderId: string,
			orderLineItemCreate: OrderLineItemCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<OrderLineItem> {
			return localVarFp
				.createOrderLineItem(orderId, orderLineItemCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 신규 상품 생성 - 사용자가 소유한 상품 중 동일한 이름이 있는지 검사
		 * @summary Create Product
		 * @param {ProductCreate} productCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createProduct(
			productCreate: ProductCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Product> {
			return localVarFp
				.createProduct(productCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 신규 상품 옵션 생성
		 * @summary Create Product Variant
		 * @param {string} productId
		 * @param {ProductVariantCreate} productVariantCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createProductVariant(
			productId: string,
			productVariantCreate: ProductVariantCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ProductVariant> {
			return localVarFp
				.createProductVariant(
					productId,
					productVariantCreate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 브랜드 삭제
		 * @summary Delete Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteBrand(
			brandId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.deleteBrand(brandId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 카테고리 삭제
		 * @summary Delete Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.deleteCategory(categoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 삭제
		 * @summary Delete Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteChannel(
			channelId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.deleteChannel(channelId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 리스팅 삭제
		 * @summary Delete Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteChannelListing(
			channelListingId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.deleteChannelListing(channelListingId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 인벤토리 삭제
		 * @summary Delete Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteInventory(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.deleteInventory(inventoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문의 상품 삭제
		 * @summary Delete Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteOrderLineItem(
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.deleteOrderLineItem(orderId, lineItemId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 삭제
		 * @summary Delete Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteProduct(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.deleteProduct(productId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 옵션 삭제
		 * @summary Delete Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteProductVariant(
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.deleteProductVariant(productId, variantId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 브랜드 상세 조회
		 * @summary Read Brand
		 * @param {string} brandId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readBrand(
			brandId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Brand> {
			return localVarFp
				.readBrand(brandId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 브랜드 목록 조회
		 * @summary Read Brands
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readBrands(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Brand>> {
			return localVarFp
				.readBrands(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 카테고리 목록 조회
		 * @summary Read Categories
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readCategories(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Category>> {
			return localVarFp
				.readCategories(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 카테고리 상세 조회
		 * @summary Read Category
		 * @param {string} categoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readCategory(
			categoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Category> {
			return localVarFp
				.readCategory(categoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 상세 조회
		 * @summary Read Channel
		 * @param {string} channelId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readChannel(
			channelId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<SalesChannel> {
			return localVarFp
				.readChannel(channelId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 리스팅 상세 조회
		 * @summary Read Channel Listing
		 * @param {string} channelListingId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readChannelListing(
			channelListingId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ChannelListing> {
			return localVarFp
				.readChannelListing(channelListingId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 리스팅 목록 조회
		 * @summary Read Channel Listings
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readChannelListings(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<ChannelListing>> {
			return localVarFp
				.readChannelListings(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 목록 조회
		 * @summary Read Channels
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readChannels(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<SalesChannel>> {
			return localVarFp
				.readChannels(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 인벤토리 목록 조회
		 * @summary Read Inventories
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readInventories(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Inventory>> {
			return localVarFp
				.readInventories(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 인벤토리 조회
		 * @summary Read Inventory
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readInventory(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Inventory> {
			return localVarFp
				.readInventory(inventoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 재고 거래 내역 상세 조회
		 * @summary Read Inventory Transaction
		 * @param {string} inventoryId
		 * @param {string} transactionId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readInventoryTransaction(
			inventoryId: string,
			transactionId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<InventoryTransaction> {
			return localVarFp
				.readInventoryTransaction(
					inventoryId,
					transactionId,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 재고 거래 내역 조회
		 * @summary Read Inventory Transactions
		 * @param {string} inventoryId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readInventoryTransactions(
			inventoryId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<InventoryTransaction>> {
			return localVarFp
				.readInventoryTransactions(inventoryId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문 상세 조회
		 * @summary Read Order
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readOrder(
			orderId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Order> {
			return localVarFp
				.readOrder(orderId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문의 상품 상세 조회
		 * @summary Read Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readOrderLineItem(
			orderId: string,
			lineItemId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<OrderLineItem> {
			return localVarFp
				.readOrderLineItem(orderId, lineItemId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문의 상품 목록 조회
		 * @summary Read Order Line Items
		 * @param {string} orderId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readOrderLineItems(
			orderId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<OrderLineItem>> {
			return localVarFp
				.readOrderLineItems(orderId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문 목록 조회
		 * @summary Read Orders
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readOrders(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Order>> {
			return localVarFp
				.readOrders(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 상세 조회
		 * @summary Read Product
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readProduct(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Product> {
			return localVarFp
				.readProduct(productId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 옵션 상세 조회
		 * @summary Read Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readProductVariant(
			productId: string,
			variantId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ProductVariant> {
			return localVarFp
				.readProductVariant(productId, variantId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 별 옵션 목록 조회
		 * @summary Read Product Variants
		 * @param {string} productId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readProductVariants(
			productId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<ProductVariant>> {
			return localVarFp
				.readProductVariants(productId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 목록 조회
		 * @summary Read Products
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		readProducts(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<Product>> {
			return localVarFp
				.readProducts(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 브랜드 수정
		 * @summary Update Brand
		 * @param {string} brandId
		 * @param {BrandCreate} brandCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateBrand(
			brandId: string,
			brandCreate: BrandCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Brand> {
			return localVarFp
				.updateBrand(brandId, brandCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 카테고리 수정
		 * @summary Update Category
		 * @param {string} categoryId
		 * @param {CategoryUpdate} categoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateCategory(
			categoryId: string,
			categoryUpdate: CategoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Category> {
			return localVarFp
				.updateCategory(categoryId, categoryUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 수정
		 * @summary Update Channel
		 * @param {string} channelId
		 * @param {SalesChannelUpdate} salesChannelUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateChannel(
			channelId: string,
			salesChannelUpdate: SalesChannelUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<SalesChannel> {
			return localVarFp
				.updateChannel(channelId, salesChannelUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 채널 리스팅 정보 수정
		 * @summary Update Channel Listing
		 * @param {string} channelListingId
		 * @param {ChannelListingUpdate} channelListingUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateChannelListing(
			channelListingId: string,
			channelListingUpdate: ChannelListingUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ChannelListing> {
			return localVarFp
				.updateChannelListing(
					channelListingId,
					channelListingUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 인벤토리 정보 수정
		 * @summary Update Inventory
		 * @param {string} inventoryId
		 * @param {InventoryUpdate} inventoryUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateInventory(
			inventoryId: string,
			inventoryUpdate: InventoryUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Inventory> {
			return localVarFp
				.updateInventory(inventoryId, inventoryUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문 수정
		 * @summary Update Order
		 * @param {string} orderId
		 * @param {OrderUpdate} orderUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOrder(
			orderId: string,
			orderUpdate: OrderUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Order> {
			return localVarFp
				.updateOrder(orderId, orderUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 주문의 상품 수정
		 * @summary Update Order Line Item
		 * @param {string} orderId
		 * @param {string} lineItemId
		 * @param {OrderLineItemUpdate} orderLineItemUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateOrderLineItem(
			orderId: string,
			lineItemId: string,
			orderLineItemUpdate: OrderLineItemUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<OrderLineItem> {
			return localVarFp
				.updateOrderLineItem(
					orderId,
					lineItemId,
					orderLineItemUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 수정
		 * @summary Update Product
		 * @param {string} productId
		 * @param {ProductUpdate} productUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateProduct(
			productId: string,
			productUpdate: ProductUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Product> {
			return localVarFp
				.updateProduct(productId, productUpdate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 상품 옵션 수정
		 * @summary Update Product Variant
		 * @param {string} productId
		 * @param {string} variantId
		 * @param {ProductVariantUpdate} productVariantUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateProductVariant(
			productId: string,
			variantId: string,
			productVariantUpdate: ProductVariantUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<ProductVariant> {
			return localVarFp
				.updateProductVariant(
					productId,
					variantId,
					productVariantUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
	/**
	 * 신규 브랜드 생성 - 사용자가 소유한 브랜드 중 동일한 이름이 있는지 검사
	 * @summary Create Brand
	 * @param {BrandCreate} brandCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createBrand(
		brandCreate: BrandCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createBrand(brandCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 신규 카테고리 생성 - 사용자가 소유한 카테고리 중 동일한 이름이 있는지 검사 - 부모 카테고리(parent_id)가 있다면, 해당 카테고리가 존재하고 현재 사용자가 소유한 카테고리여야 함
	 * @summary Create Category
	 * @param {CategoryCreate} categoryCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createCategory(
		categoryCreate: CategoryCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createCategory(categoryCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 신규 채널 생성
	 * @summary Create Channel
	 * @param {SalesChannelCreate} salesChannelCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createChannel(
		salesChannelCreate: SalesChannelCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createChannel(salesChannelCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 신규 채널 리스팅 생성
	 * @summary Create Channel Listing
	 * @param {ChannelListingCreate} channelListingCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createChannelListing(
		channelListingCreate: ChannelListingCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createChannelListing(channelListingCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 신규 인벤토리 생성
	 * @summary Create Inventory
	 * @param {InventoryCreate} inventoryCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createInventory(
		inventoryCreate: InventoryCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createInventory(inventoryCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 신규 재고 생성
	 * @summary Create Invetory Transaction
	 * @param {string} inventoryId
	 * @param {InventoryTransactionRequest} inventoryTransactionRequest
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createInvetoryTransaction(
		inventoryId: string,
		inventoryTransactionRequest: InventoryTransactionRequest,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createInvetoryTransaction(
				inventoryId,
				inventoryTransactionRequest,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 신규 주문 생성
	 * @summary Create Order
	 * @param {OrderCreate} orderCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createOrder(
		orderCreate: OrderCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createOrder(orderCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문에 상품 추가
	 * @summary Create Order Line Item
	 * @param {string} orderId
	 * @param {OrderLineItemCreate} orderLineItemCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createOrderLineItem(
		orderId: string,
		orderLineItemCreate: OrderLineItemCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createOrderLineItem(orderId, orderLineItemCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 신규 상품 생성 - 사용자가 소유한 상품 중 동일한 이름이 있는지 검사
	 * @summary Create Product
	 * @param {ProductCreate} productCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createProduct(
		productCreate: ProductCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createProduct(productCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 신규 상품 옵션 생성
	 * @summary Create Product Variant
	 * @param {string} productId
	 * @param {ProductVariantCreate} productVariantCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public createProductVariant(
		productId: string,
		productVariantCreate: ProductVariantCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.createProductVariant(
				productId,
				productVariantCreate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 브랜드 삭제
	 * @summary Delete Brand
	 * @param {string} brandId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteBrand(
		brandId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.deleteBrand(brandId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 카테고리 삭제
	 * @summary Delete Category
	 * @param {string} categoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteCategory(
		categoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.deleteCategory(categoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 삭제
	 * @summary Delete Channel
	 * @param {string} channelId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteChannel(
		channelId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.deleteChannel(channelId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 리스팅 삭제
	 * @summary Delete Channel Listing
	 * @param {string} channelListingId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteChannelListing(
		channelListingId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.deleteChannelListing(channelListingId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 인벤토리 삭제
	 * @summary Delete Inventory
	 * @param {string} inventoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteInventory(
		inventoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.deleteInventory(inventoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문의 상품 삭제
	 * @summary Delete Order Line Item
	 * @param {string} orderId
	 * @param {string} lineItemId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteOrderLineItem(
		orderId: string,
		lineItemId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.deleteOrderLineItem(orderId, lineItemId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 삭제
	 * @summary Delete Product
	 * @param {string} productId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteProduct(
		productId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.deleteProduct(productId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 옵션 삭제
	 * @summary Delete Product Variant
	 * @param {string} productId
	 * @param {string} variantId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public deleteProductVariant(
		productId: string,
		variantId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.deleteProductVariant(productId, variantId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 브랜드 상세 조회
	 * @summary Read Brand
	 * @param {string} brandId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readBrand(
		brandId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readBrand(brandId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 브랜드 목록 조회
	 * @summary Read Brands
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readBrands(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readBrands(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 카테고리 목록 조회
	 * @summary Read Categories
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readCategories(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readCategories(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 카테고리 상세 조회
	 * @summary Read Category
	 * @param {string} categoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readCategory(
		categoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readCategory(categoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 상세 조회
	 * @summary Read Channel
	 * @param {string} channelId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readChannel(
		channelId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readChannel(channelId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 리스팅 상세 조회
	 * @summary Read Channel Listing
	 * @param {string} channelListingId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readChannelListing(
		channelListingId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readChannelListing(channelListingId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 리스팅 목록 조회
	 * @summary Read Channel Listings
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readChannelListings(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readChannelListings(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 목록 조회
	 * @summary Read Channels
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readChannels(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readChannels(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 인벤토리 목록 조회
	 * @summary Read Inventories
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readInventories(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readInventories(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 인벤토리 조회
	 * @summary Read Inventory
	 * @param {string} inventoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readInventory(
		inventoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readInventory(inventoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 재고 거래 내역 상세 조회
	 * @summary Read Inventory Transaction
	 * @param {string} inventoryId
	 * @param {string} transactionId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readInventoryTransaction(
		inventoryId: string,
		transactionId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readInventoryTransaction(
				inventoryId,
				transactionId,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 재고 거래 내역 조회
	 * @summary Read Inventory Transactions
	 * @param {string} inventoryId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readInventoryTransactions(
		inventoryId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readInventoryTransactions(inventoryId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문 상세 조회
	 * @summary Read Order
	 * @param {string} orderId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readOrder(
		orderId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readOrder(orderId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문의 상품 상세 조회
	 * @summary Read Order Line Item
	 * @param {string} orderId
	 * @param {string} lineItemId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readOrderLineItem(
		orderId: string,
		lineItemId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readOrderLineItem(orderId, lineItemId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문의 상품 목록 조회
	 * @summary Read Order Line Items
	 * @param {string} orderId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readOrderLineItems(
		orderId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readOrderLineItems(orderId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문 목록 조회
	 * @summary Read Orders
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readOrders(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readOrders(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 상세 조회
	 * @summary Read Product
	 * @param {string} productId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readProduct(
		productId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readProduct(productId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 옵션 상세 조회
	 * @summary Read Product Variant
	 * @param {string} productId
	 * @param {string} variantId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readProductVariant(
		productId: string,
		variantId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readProductVariant(productId, variantId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 별 옵션 목록 조회
	 * @summary Read Product Variants
	 * @param {string} productId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readProductVariants(
		productId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readProductVariants(productId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 목록 조회
	 * @summary Read Products
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public readProducts(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.readProducts(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 브랜드 수정
	 * @summary Update Brand
	 * @param {string} brandId
	 * @param {BrandCreate} brandCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public updateBrand(
		brandId: string,
		brandCreate: BrandCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.updateBrand(brandId, brandCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 카테고리 수정
	 * @summary Update Category
	 * @param {string} categoryId
	 * @param {CategoryUpdate} categoryUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public updateCategory(
		categoryId: string,
		categoryUpdate: CategoryUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.updateCategory(categoryId, categoryUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 수정
	 * @summary Update Channel
	 * @param {string} channelId
	 * @param {SalesChannelUpdate} salesChannelUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public updateChannel(
		channelId: string,
		salesChannelUpdate: SalesChannelUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.updateChannel(channelId, salesChannelUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 채널 리스팅 정보 수정
	 * @summary Update Channel Listing
	 * @param {string} channelListingId
	 * @param {ChannelListingUpdate} channelListingUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public updateChannelListing(
		channelListingId: string,
		channelListingUpdate: ChannelListingUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.updateChannelListing(
				channelListingId,
				channelListingUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 인벤토리 정보 수정
	 * @summary Update Inventory
	 * @param {string} inventoryId
	 * @param {InventoryUpdate} inventoryUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public updateInventory(
		inventoryId: string,
		inventoryUpdate: InventoryUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.updateInventory(inventoryId, inventoryUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문 수정
	 * @summary Update Order
	 * @param {string} orderId
	 * @param {OrderUpdate} orderUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public updateOrder(
		orderId: string,
		orderUpdate: OrderUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.updateOrder(orderId, orderUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 주문의 상품 수정
	 * @summary Update Order Line Item
	 * @param {string} orderId
	 * @param {string} lineItemId
	 * @param {OrderLineItemUpdate} orderLineItemUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public updateOrderLineItem(
		orderId: string,
		lineItemId: string,
		orderLineItemUpdate: OrderLineItemUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.updateOrderLineItem(
				orderId,
				lineItemId,
				orderLineItemUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 수정
	 * @summary Update Product
	 * @param {string} productId
	 * @param {ProductUpdate} productUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public updateProduct(
		productId: string,
		productUpdate: ProductUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.updateProduct(productId, productUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 상품 옵션 수정
	 * @summary Update Product Variant
	 * @param {string} productId
	 * @param {string} variantId
	 * @param {ProductVariantUpdate} productVariantUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public updateProductVariant(
		productId: string,
		variantId: string,
		productVariantUpdate: ProductVariantUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return DefaultApiFp(this.configuration)
			.updateProductVariant(
				productId,
				variantId,
				productVariantUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * HealthCheckApi - axios parameter creator
 * @export
 */
export const HealthCheckApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary Health Check
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthCheckHealthCheck: async (
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/health-check`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		HealthCheckApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Health Check
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async healthCheckHealthCheck(
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.healthCheckHealthCheck(options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["HealthCheckApi.healthCheckHealthCheck"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = HealthCheckApiFp(configuration);
	return {
		/**
		 *
		 * @summary Health Check
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		healthCheckHealthCheck(
			options?: RawAxiosRequestConfig,
		): AxiosPromise<boolean> {
			return localVarFp
				.healthCheckHealthCheck(options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI {
	/**
	 *
	 * @summary Health Check
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof HealthCheckApi
	 */
	public healthCheckHealthCheck(options?: RawAxiosRequestConfig) {
		return HealthCheckApiFp(this.configuration)
			.healthCheckHealthCheck(options)
			.then((request) => request(this.axios, this.basePath));
	}
}
