/* tslint:disable */
/* eslint-disable */
/**
 * MySingle - Quant (dev)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
	DUMMY_BASE_URL,
	assertParamExists,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	serializeDataIfNeeded,
	toPathString,
	createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import {
	BASE_PATH,
	COLLECTION_FORMATS,
	BaseAPI,
	RequiredError,
	operationServerMap,
} from "./base";

/**
 *
 * @export
 * @interface Asset
 */
export interface Asset {
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	_id?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	created_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	updated_at?: string;
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	symbol: string;
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	asset_name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	asset_type: string;
	/**
	 *
	 * @type {number}
	 * @memberof Asset
	 */
	current_price?: number | null;
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	exchange?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	currency: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	sector?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof Asset
	 */
	industry?: string | null;
	/**
	 *
	 * @type {number}
	 * @memberof Asset
	 */
	eps?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof Asset
	 */
	per?: number | null;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof Asset
	 */
	tags?: Array<string>;
	/**
	 *
	 * @type {boolean}
	 * @memberof Asset
	 */
	deleted?: boolean;
}
/**
 *
 * @export
 * @interface AssetRead
 */
export interface AssetRead {
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	symbol: string;
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	asset_name: string;
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	asset_type: string;
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	exchange: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	currency: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	sector: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	industry: string | null;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof AssetRead
	 */
	tags: Array<string> | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	created_at: string;
	/**
	 *
	 * @type {string}
	 * @memberof AssetRead
	 */
	updated_at: string;
}
/**
 *
 * @export
 * @interface AssetUpdate
 */
export interface AssetUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof AssetUpdate
	 */
	symbol: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetUpdate
	 */
	asset_name: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetUpdate
	 */
	asset_type: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetUpdate
	 */
	exchange: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetUpdate
	 */
	currency: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetUpdate
	 */
	sector: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof AssetUpdate
	 */
	industry: string | null;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof AssetUpdate
	 */
	tags: Array<string> | null;
}
/**
 *
 * @export
 * @interface BacktestCreate
 */
export interface BacktestCreate {
	/**
	 *
	 * @type {string}
	 * @memberof BacktestCreate
	 */
	strategy_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestCreate
	 */
	start_date: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestCreate
	 */
	end_date: string;
	/**
	 *
	 * @type {{ [key: string]: number; }}
	 * @memberof BacktestCreate
	 */
	parameters?: { [key: string]: number };
}
/**
 *
 * @export
 * @interface BacktestRead
 */
export interface BacktestRead {
	/**
	 *
	 * @type {string}
	 * @memberof BacktestRead
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestRead
	 */
	user_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestRead
	 */
	strategy_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestRead
	 */
	start_date: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestRead
	 */
	end_date: string;
	/**
	 *
	 * @type {{ [key: string]: number; }}
	 * @memberof BacktestRead
	 */
	parameters: { [key: string]: number };
	/**
	 *
	 * @type {string}
	 * @memberof BacktestRead
	 */
	status: string;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestRead
	 */
	total_return: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestRead
	 */
	max_drawdown: number | null;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestRead
	 */
	created_at: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestRead
	 */
	updated_at: string;
}
/**
 *
 * @export
 * @interface BacktestResultCreate
 */
export interface BacktestResultCreate {
	/**
	 *
	 * @type {string}
	 * @memberof BacktestResultCreate
	 */
	backtest_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestResultCreate
	 */
	date: string;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestResultCreate
	 */
	portfolio_value: number;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestResultCreate
	 */
	daily_return?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestResultCreate
	 */
	cum_return?: number | null;
}
/**
 *
 * @export
 * @interface BacktestResultRead
 */
export interface BacktestResultRead {
	/**
	 *
	 * @type {string}
	 * @memberof BacktestResultRead
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestResultRead
	 */
	backtest_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof BacktestResultRead
	 */
	date: string;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestResultRead
	 */
	portfolio_value: number;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestResultRead
	 */
	daily_return: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestResultRead
	 */
	cum_return: number | null;
}
/**
 *
 * @export
 * @interface BacktestUpdate
 */
export interface BacktestUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof BacktestUpdate
	 */
	status?: BacktestUpdateStatusEnum | null;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestUpdate
	 */
	total_return?: number | null;
	/**
	 *
	 * @type {number}
	 * @memberof BacktestUpdate
	 */
	max_drawdown?: number | null;
}

export const BacktestUpdateStatusEnum = {
	Pending: "pending",
	Running: "running",
	Completed: "completed",
	Failed: "failed",
} as const;

export type BacktestUpdateStatusEnum =
	(typeof BacktestUpdateStatusEnum)[keyof typeof BacktestUpdateStatusEnum];

/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
	/**
	 *
	 * @type {Array<ValidationError>}
	 * @memberof HTTPValidationError
	 */
	detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
	/**
	 *
	 * @type {string}
	 * @memberof Message
	 */
	message: string;
}
/**
 *
 * @export
 * @interface StrategyCreate
 */
export interface StrategyCreate {
	/**
	 *
	 * @type {string}
	 * @memberof StrategyCreate
	 */
	name: string;
	/**
	 *
	 * @type {{ [key: string]: number; }}
	 * @memberof StrategyCreate
	 */
	parameters?: { [key: string]: number };
	/**
	 *
	 * @type {string}
	 * @memberof StrategyCreate
	 */
	description?: string | null;
}
/**
 *
 * @export
 * @interface StrategyRead
 */
export interface StrategyRead {
	/**
	 *
	 * @type {string}
	 * @memberof StrategyRead
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof StrategyRead
	 */
	user_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof StrategyRead
	 */
	name: string;
	/**
	 *
	 * @type {{ [key: string]: number; }}
	 * @memberof StrategyRead
	 */
	parameters: { [key: string]: number };
	/**
	 *
	 * @type {string}
	 * @memberof StrategyRead
	 */
	description: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof StrategyRead
	 */
	created_at: string;
	/**
	 *
	 * @type {string}
	 * @memberof StrategyRead
	 */
	updated_at: string;
}
/**
 *
 * @export
 * @interface StrategyUpdate
 */
export interface StrategyUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof StrategyUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {{ [key: string]: number; }}
	 * @memberof StrategyUpdate
	 */
	parameters?: { [key: string]: number } | null;
	/**
	 *
	 * @type {string}
	 * @memberof StrategyUpdate
	 */
	description?: string | null;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
	/**
	 *
	 * @type {Array<ValidationErrorLocInner>}
	 * @memberof ValidationError
	 */
	loc: Array<ValidationErrorLocInner>;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	msg: string;
	/**
	 *
	 * @type {string}
	 * @memberof ValidationError
	 */
	type: string;
}
/**
 *
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {}
/**
 *
 * @export
 * @interface WatchlistCreate
 */
export interface WatchlistCreate {
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistCreate
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistCreate
	 */
	description?: string | null;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof WatchlistCreate
	 */
	assets?: Array<string>;
}
/**
 *
 * @export
 * @interface WatchlistRead
 */
export interface WatchlistRead {
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistRead
	 */
	id: string;
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistRead
	 */
	user_id: string;
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistRead
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistRead
	 */
	description: string | null;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof WatchlistRead
	 */
	assets: Array<string>;
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistRead
	 */
	created_at: string;
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistRead
	 */
	updated_at: string;
}
/**
 *
 * @export
 * @interface WatchlistUpdate
 */
export interface WatchlistUpdate {
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistUpdate
	 */
	name?: string | null;
	/**
	 *
	 * @type {string}
	 * @memberof WatchlistUpdate
	 */
	description?: string | null;
	/**
	 *
	 * @type {Array<string>}
	 * @memberof WatchlistUpdate
	 */
	assets?: Array<string> | null;
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 새로운 자산(종목) 정보 등록
		 * @summary Create Asset
		 * @param {string} symbol Symbol of the asset
		 * @param {Array<string> | null} [requestBody]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsCreateAsset: async (
			symbol: string,
			requestBody?: Array<string> | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("assetsCreateAsset", "symbol", symbol);
			const localVarPath = `/api/v1/assets/assets/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				requestBody,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 새로운 자산(종목) 정보 등록
		 * @summary Create Asset
		 * @param {string} symbol Symbol of the asset
		 * @param {Array<string> | null} [requestBody]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsCreateAsset_1: async (
			symbol: string,
			requestBody?: Array<string> | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("assetsCreateAsset_1", "symbol", symbol);
			const localVarPath = `/api/v1/assets/assets/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				requestBody,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 자산 정보 삭제
		 * @summary Delete Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsDeleteAsset: async (
			assetId: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'assetId' is not null or undefined
			assertParamExists("assetsDeleteAsset", "assetId", assetId);
			const localVarPath = `/api/v1/assets/assets/{asset_id}`.replace(
				`{${"asset_id"}}`,
				encodeURIComponent(String(assetId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 자산 정보 삭제
		 * @summary Delete Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsDeleteAsset_2: async (
			assetId: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'assetId' is not null or undefined
			assertParamExists("assetsDeleteAsset_2", "assetId", assetId);
			const localVarPath = `/api/v1/assets/assets/{asset_id}`.replace(
				`{${"asset_id"}}`,
				encodeURIComponent(String(assetId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 단일 자산(종목) 상세 조회
		 * @summary Get Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsGetAsset: async (
			assetId: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'assetId' is not null or undefined
			assertParamExists("assetsGetAsset", "assetId", assetId);
			const localVarPath = `/api/v1/assets/assets/{asset_id}`.replace(
				`{${"asset_id"}}`,
				encodeURIComponent(String(assetId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 단일 자산(종목) 상세 조회
		 * @summary Get Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsGetAsset_3: async (
			assetId: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'assetId' is not null or undefined
			assertParamExists("assetsGetAsset_3", "assetId", assetId);
			const localVarPath = `/api/v1/assets/assets/{asset_id}`.replace(
				`{${"asset_id"}}`,
				encodeURIComponent(String(assetId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 자산 목록 조회 + 간단한 필터링
		 * @summary List Assets
		 * @param {string | null} [symbol] 심볼로 필터링
		 * @param {string | null} [assetType] 자산유형(equity, etf, etc.)
		 * @param {string | null} [exchange] 거래소(NYSE, NASDAQ 등)
		 * @param {string | null} [sector] 업종(Technology, Healthcare 등)
		 * @param {number} [skip]
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsListAssets: async (
			symbol?: string | null,
			assetType?: string | null,
			exchange?: string | null,
			sector?: string | null,
			skip?: number,
			limit?: number,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/assets/assets/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			if (assetType !== undefined) {
				localVarQueryParameter["asset_type"] = assetType;
			}

			if (exchange !== undefined) {
				localVarQueryParameter["exchange"] = exchange;
			}

			if (sector !== undefined) {
				localVarQueryParameter["sector"] = sector;
			}

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 자산 목록 조회 + 간단한 필터링
		 * @summary List Assets
		 * @param {string | null} [symbol] 심볼로 필터링
		 * @param {string | null} [assetType] 자산유형(equity, etf, etc.)
		 * @param {string | null} [exchange] 거래소(NYSE, NASDAQ 등)
		 * @param {string | null} [sector] 업종(Technology, Healthcare 등)
		 * @param {number} [skip]
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsListAssets_4: async (
			symbol?: string | null,
			assetType?: string | null,
			exchange?: string | null,
			sector?: string | null,
			skip?: number,
			limit?: number,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/assets/assets/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			if (assetType !== undefined) {
				localVarQueryParameter["asset_type"] = assetType;
			}

			if (exchange !== undefined) {
				localVarQueryParameter["exchange"] = exchange;
			}

			if (sector !== undefined) {
				localVarQueryParameter["sector"] = sector;
			}

			if (skip !== undefined) {
				localVarQueryParameter["skip"] = skip;
			}

			if (limit !== undefined) {
				localVarQueryParameter["limit"] = limit;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 자산 정보 수정 (전체/부분 업데이트)
		 * @summary Update Asset
		 * @param {string} assetId
		 * @param {AssetUpdate} assetUpdate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsUpdateAsset: async (
			assetId: string,
			assetUpdate: AssetUpdate,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'assetId' is not null or undefined
			assertParamExists("assetsUpdateAsset", "assetId", assetId);
			// verify required parameter 'assetUpdate' is not null or undefined
			assertParamExists("assetsUpdateAsset", "assetUpdate", assetUpdate);
			const localVarPath = `/api/v1/assets/assets/{asset_id}`.replace(
				`{${"asset_id"}}`,
				encodeURIComponent(String(assetId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				assetUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 자산 정보 수정 (전체/부분 업데이트)
		 * @summary Update Asset
		 * @param {string} assetId
		 * @param {AssetUpdate} assetUpdate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsUpdateAsset_5: async (
			assetId: string,
			assetUpdate: AssetUpdate,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'assetId' is not null or undefined
			assertParamExists("assetsUpdateAsset_5", "assetId", assetId);
			// verify required parameter 'assetUpdate' is not null or undefined
			assertParamExists("assetsUpdateAsset_5", "assetUpdate", assetUpdate);
			const localVarPath = `/api/v1/assets/assets/{asset_id}`.replace(
				`{${"asset_id"}}`,
				encodeURIComponent(String(assetId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				assetUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration);
	return {
		/**
		 * 새로운 자산(종목) 정보 등록
		 * @summary Create Asset
		 * @param {string} symbol Symbol of the asset
		 * @param {Array<string> | null} [requestBody]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsCreateAsset(
			symbol: string,
			requestBody?: Array<string> | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.assetsCreateAsset(
					symbol,
					requestBody,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsCreateAsset"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 새로운 자산(종목) 정보 등록
		 * @summary Create Asset
		 * @param {string} symbol Symbol of the asset
		 * @param {Array<string> | null} [requestBody]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsCreateAsset_1(
			symbol: string,
			requestBody?: Array<string> | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.assetsCreateAsset_1(
					symbol,
					requestBody,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsCreateAsset_1"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 자산 정보 삭제
		 * @summary Delete Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsDeleteAsset(
			assetId: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.assetsDeleteAsset(assetId, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsDeleteAsset"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 자산 정보 삭제
		 * @summary Delete Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsDeleteAsset_2(
			assetId: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.assetsDeleteAsset_2(assetId, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsDeleteAsset_2"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 단일 자산(종목) 상세 조회
		 * @summary Get Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsGetAsset(
			assetId: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetRead>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.assetsGetAsset(
				assetId,
				options,
			);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsGetAsset"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 단일 자산(종목) 상세 조회
		 * @summary Get Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsGetAsset_3(
			assetId: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.assetsGetAsset_3(assetId, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsGetAsset_3"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 자산 목록 조회 + 간단한 필터링
		 * @summary List Assets
		 * @param {string | null} [symbol] 심볼로 필터링
		 * @param {string | null} [assetType] 자산유형(equity, etf, etc.)
		 * @param {string | null} [exchange] 거래소(NYSE, NASDAQ 등)
		 * @param {string | null} [sector] 업종(Technology, Healthcare 등)
		 * @param {number} [skip]
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsListAssets(
			symbol?: string | null,
			assetType?: string | null,
			exchange?: string | null,
			sector?: string | null,
			skip?: number,
			limit?: number,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<AssetRead>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.assetsListAssets(
					symbol,
					assetType,
					exchange,
					sector,
					skip,
					limit,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsListAssets"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 자산 목록 조회 + 간단한 필터링
		 * @summary List Assets
		 * @param {string | null} [symbol] 심볼로 필터링
		 * @param {string | null} [assetType] 자산유형(equity, etf, etc.)
		 * @param {string | null} [exchange] 거래소(NYSE, NASDAQ 등)
		 * @param {string | null} [sector] 업종(Technology, Healthcare 등)
		 * @param {number} [skip]
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsListAssets_4(
			symbol?: string | null,
			assetType?: string | null,
			exchange?: string | null,
			sector?: string | null,
			skip?: number,
			limit?: number,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<AssetRead>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.assetsListAssets_4(
					symbol,
					assetType,
					exchange,
					sector,
					skip,
					limit,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsListAssets_4"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 자산 정보 수정 (전체/부분 업데이트)
		 * @summary Update Asset
		 * @param {string} assetId
		 * @param {AssetUpdate} assetUpdate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsUpdateAsset(
			assetId: string,
			assetUpdate: AssetUpdate,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.assetsUpdateAsset(
					assetId,
					assetUpdate,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsUpdateAsset"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 자산 정보 수정 (전체/부분 업데이트)
		 * @summary Update Asset
		 * @param {string} assetId
		 * @param {AssetUpdate} assetUpdate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async assetsUpdateAsset_5(
			assetId: string,
			assetUpdate: AssetUpdate,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.assetsUpdateAsset_5(
					assetId,
					assetUpdate,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["AssetsApi.assetsUpdateAsset_5"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = AssetsApiFp(configuration);
	return {
		/**
		 * 새로운 자산(종목) 정보 등록
		 * @summary Create Asset
		 * @param {string} symbol Symbol of the asset
		 * @param {Array<string> | null} [requestBody]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsCreateAsset(
			symbol: string,
			requestBody?: Array<string> | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Asset> {
			return localVarFp
				.assetsCreateAsset(symbol, requestBody, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 새로운 자산(종목) 정보 등록
		 * @summary Create Asset
		 * @param {string} symbol Symbol of the asset
		 * @param {Array<string> | null} [requestBody]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsCreateAsset_1(
			symbol: string,
			requestBody?: Array<string> | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Asset> {
			return localVarFp
				.assetsCreateAsset_1(symbol, requestBody, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 자산 정보 삭제
		 * @summary Delete Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsDeleteAsset(
			assetId: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.assetsDeleteAsset(assetId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 자산 정보 삭제
		 * @summary Delete Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsDeleteAsset_2(
			assetId: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.assetsDeleteAsset_2(assetId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 단일 자산(종목) 상세 조회
		 * @summary Get Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsGetAsset(
			assetId: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AssetRead> {
			return localVarFp
				.assetsGetAsset(assetId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 단일 자산(종목) 상세 조회
		 * @summary Get Asset
		 * @param {string} assetId
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsGetAsset_3(
			assetId: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AssetRead> {
			return localVarFp
				.assetsGetAsset_3(assetId, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 자산 목록 조회 + 간단한 필터링
		 * @summary List Assets
		 * @param {string | null} [symbol] 심볼로 필터링
		 * @param {string | null} [assetType] 자산유형(equity, etf, etc.)
		 * @param {string | null} [exchange] 거래소(NYSE, NASDAQ 등)
		 * @param {string | null} [sector] 업종(Technology, Healthcare 등)
		 * @param {number} [skip]
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsListAssets(
			symbol?: string | null,
			assetType?: string | null,
			exchange?: string | null,
			sector?: string | null,
			skip?: number,
			limit?: number,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<AssetRead>> {
			return localVarFp
				.assetsListAssets(
					symbol,
					assetType,
					exchange,
					sector,
					skip,
					limit,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 자산 목록 조회 + 간단한 필터링
		 * @summary List Assets
		 * @param {string | null} [symbol] 심볼로 필터링
		 * @param {string | null} [assetType] 자산유형(equity, etf, etc.)
		 * @param {string | null} [exchange] 거래소(NYSE, NASDAQ 등)
		 * @param {string | null} [sector] 업종(Technology, Healthcare 등)
		 * @param {number} [skip]
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsListAssets_4(
			symbol?: string | null,
			assetType?: string | null,
			exchange?: string | null,
			sector?: string | null,
			skip?: number,
			limit?: number,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<AssetRead>> {
			return localVarFp
				.assetsListAssets_4(
					symbol,
					assetType,
					exchange,
					sector,
					skip,
					limit,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 자산 정보 수정 (전체/부분 업데이트)
		 * @summary Update Asset
		 * @param {string} assetId
		 * @param {AssetUpdate} assetUpdate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsUpdateAsset(
			assetId: string,
			assetUpdate: AssetUpdate,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AssetRead> {
			return localVarFp
				.assetsUpdateAsset(assetId, assetUpdate, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 자산 정보 수정 (전체/부분 업데이트)
		 * @summary Update Asset
		 * @param {string} assetId
		 * @param {AssetUpdate} assetUpdate
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		assetsUpdateAsset_5(
			assetId: string,
			assetUpdate: AssetUpdate,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<AssetRead> {
			return localVarFp
				.assetsUpdateAsset_5(assetId, assetUpdate, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
	/**
	 * 새로운 자산(종목) 정보 등록
	 * @summary Create Asset
	 * @param {string} symbol Symbol of the asset
	 * @param {Array<string> | null} [requestBody]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsCreateAsset(
		symbol: string,
		requestBody?: Array<string> | null,
		options?: RawAxiosRequestConfig,
	) {
		return AssetsApiFp(this.configuration)
			.assetsCreateAsset(symbol, requestBody, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 새로운 자산(종목) 정보 등록
	 * @summary Create Asset
	 * @param {string} symbol Symbol of the asset
	 * @param {Array<string> | null} [requestBody]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsCreateAsset_1(
		symbol: string,
		requestBody?: Array<string> | null,
		options?: RawAxiosRequestConfig,
	) {
		return AssetsApiFp(this.configuration)
			.assetsCreateAsset_1(symbol, requestBody, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 자산 정보 삭제
	 * @summary Delete Asset
	 * @param {string} assetId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsDeleteAsset(assetId: string, options?: RawAxiosRequestConfig) {
		return AssetsApiFp(this.configuration)
			.assetsDeleteAsset(assetId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 자산 정보 삭제
	 * @summary Delete Asset
	 * @param {string} assetId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsDeleteAsset_2(assetId: string, options?: RawAxiosRequestConfig) {
		return AssetsApiFp(this.configuration)
			.assetsDeleteAsset_2(assetId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 단일 자산(종목) 상세 조회
	 * @summary Get Asset
	 * @param {string} assetId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsGetAsset(assetId: string, options?: RawAxiosRequestConfig) {
		return AssetsApiFp(this.configuration)
			.assetsGetAsset(assetId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 단일 자산(종목) 상세 조회
	 * @summary Get Asset
	 * @param {string} assetId
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsGetAsset_3(assetId: string, options?: RawAxiosRequestConfig) {
		return AssetsApiFp(this.configuration)
			.assetsGetAsset_3(assetId, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 자산 목록 조회 + 간단한 필터링
	 * @summary List Assets
	 * @param {string | null} [symbol] 심볼로 필터링
	 * @param {string | null} [assetType] 자산유형(equity, etf, etc.)
	 * @param {string | null} [exchange] 거래소(NYSE, NASDAQ 등)
	 * @param {string | null} [sector] 업종(Technology, Healthcare 등)
	 * @param {number} [skip]
	 * @param {number} [limit]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsListAssets(
		symbol?: string | null,
		assetType?: string | null,
		exchange?: string | null,
		sector?: string | null,
		skip?: number,
		limit?: number,
		options?: RawAxiosRequestConfig,
	) {
		return AssetsApiFp(this.configuration)
			.assetsListAssets(
				symbol,
				assetType,
				exchange,
				sector,
				skip,
				limit,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 자산 목록 조회 + 간단한 필터링
	 * @summary List Assets
	 * @param {string | null} [symbol] 심볼로 필터링
	 * @param {string | null} [assetType] 자산유형(equity, etf, etc.)
	 * @param {string | null} [exchange] 거래소(NYSE, NASDAQ 등)
	 * @param {string | null} [sector] 업종(Technology, Healthcare 등)
	 * @param {number} [skip]
	 * @param {number} [limit]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsListAssets_4(
		symbol?: string | null,
		assetType?: string | null,
		exchange?: string | null,
		sector?: string | null,
		skip?: number,
		limit?: number,
		options?: RawAxiosRequestConfig,
	) {
		return AssetsApiFp(this.configuration)
			.assetsListAssets_4(
				symbol,
				assetType,
				exchange,
				sector,
				skip,
				limit,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 자산 정보 수정 (전체/부분 업데이트)
	 * @summary Update Asset
	 * @param {string} assetId
	 * @param {AssetUpdate} assetUpdate
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsUpdateAsset(
		assetId: string,
		assetUpdate: AssetUpdate,
		options?: RawAxiosRequestConfig,
	) {
		return AssetsApiFp(this.configuration)
			.assetsUpdateAsset(assetId, assetUpdate, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 자산 정보 수정 (전체/부분 업데이트)
	 * @summary Update Asset
	 * @param {string} assetId
	 * @param {AssetUpdate} assetUpdate
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AssetsApi
	 */
	public assetsUpdateAsset_5(
		assetId: string,
		assetUpdate: AssetUpdate,
		options?: RawAxiosRequestConfig,
	) {
		return AssetsApiFp(this.configuration)
			.assetsUpdateAsset_5(assetId, assetUpdate, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * BacktestResultsApi - axios parameter creator
 * @export
 */
export const BacktestResultsApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 일자별 결과 저장 (배치/시뮬레이션 단계에서 호출 가능)
		 * @summary Create Backtest Result
		 * @param {BacktestResultCreate} backtestResultCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsCreateBacktestResult: async (
			backtestResultCreate: BacktestResultCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestResultCreate' is not null or undefined
			assertParamExists(
				"backtestResultsCreateBacktestResult",
				"backtestResultCreate",
				backtestResultCreate,
			);
			const localVarPath = `/api/v1/backtest-results/backtest-results/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				backtestResultCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 일자별 결과 저장 (배치/시뮬레이션 단계에서 호출 가능)
		 * @summary Create Backtest Result
		 * @param {BacktestResultCreate} backtestResultCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsCreateBacktestResult_1: async (
			backtestResultCreate: BacktestResultCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestResultCreate' is not null or undefined
			assertParamExists(
				"backtestResultsCreateBacktestResult_1",
				"backtestResultCreate",
				backtestResultCreate,
			);
			const localVarPath = `/api/v1/backtest-results/backtest-results/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				backtestResultCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsDeleteBacktestResult: async (
			resultId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'resultId' is not null or undefined
			assertParamExists(
				"backtestResultsDeleteBacktestResult",
				"resultId",
				resultId,
			);
			const localVarPath =
				`/api/v1/backtest-results/backtest-results/{result_id}`.replace(
					`{${"result_id"}}`,
					encodeURIComponent(String(resultId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsDeleteBacktestResult_2: async (
			resultId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'resultId' is not null or undefined
			assertParamExists(
				"backtestResultsDeleteBacktestResult_2",
				"resultId",
				resultId,
			);
			const localVarPath =
				`/api/v1/backtest-results/backtest-results/{result_id}`.replace(
					`{${"result_id"}}`,
					encodeURIComponent(String(resultId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsGetBacktestResult: async (
			resultId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'resultId' is not null or undefined
			assertParamExists(
				"backtestResultsGetBacktestResult",
				"resultId",
				resultId,
			);
			const localVarPath =
				`/api/v1/backtest-results/backtest-results/{result_id}`.replace(
					`{${"result_id"}}`,
					encodeURIComponent(String(resultId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsGetBacktestResult_3: async (
			resultId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'resultId' is not null or undefined
			assertParamExists(
				"backtestResultsGetBacktestResult_3",
				"resultId",
				resultId,
			);
			const localVarPath =
				`/api/v1/backtest-results/backtest-results/{result_id}`.replace(
					`{${"result_id"}}`,
					encodeURIComponent(String(resultId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 해당 백테스트의 전체 결과 시점 목록 조회
		 * @summary List Backtest Results
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsListBacktestResults: async (
			backtestId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists(
				"backtestResultsListBacktestResults",
				"backtestId",
				backtestId,
			);
			const localVarPath = `/api/v1/backtest-results/backtest-results/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			if (backtestId !== undefined) {
				localVarQueryParameter["backtest_id"] = backtestId;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 해당 백테스트의 전체 결과 시점 목록 조회
		 * @summary List Backtest Results
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsListBacktestResults_4: async (
			backtestId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists(
				"backtestResultsListBacktestResults_4",
				"backtestId",
				backtestId,
			);
			const localVarPath = `/api/v1/backtest-results/backtest-results/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			if (backtestId !== undefined) {
				localVarQueryParameter["backtest_id"] = backtestId;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * BacktestResultsApi - functional programming interface
 * @export
 */
export const BacktestResultsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		BacktestResultsApiAxiosParamCreator(configuration);
	return {
		/**
		 * 일자별 결과 저장 (배치/시뮬레이션 단계에서 호출 가능)
		 * @summary Create Backtest Result
		 * @param {BacktestResultCreate} backtestResultCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestResultsCreateBacktestResult(
			backtestResultCreate: BacktestResultCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<BacktestResultRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestResultsCreateBacktestResult(
					backtestResultCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"BacktestResultsApi.backtestResultsCreateBacktestResult"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 일자별 결과 저장 (배치/시뮬레이션 단계에서 호출 가능)
		 * @summary Create Backtest Result
		 * @param {BacktestResultCreate} backtestResultCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestResultsCreateBacktestResult_1(
			backtestResultCreate: BacktestResultCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<BacktestResultRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestResultsCreateBacktestResult_1(
					backtestResultCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"BacktestResultsApi.backtestResultsCreateBacktestResult_1"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Delete Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestResultsDeleteBacktestResult(
			resultId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestResultsDeleteBacktestResult(
					resultId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"BacktestResultsApi.backtestResultsDeleteBacktestResult"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Delete Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestResultsDeleteBacktestResult_2(
			resultId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestResultsDeleteBacktestResult_2(
					resultId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"BacktestResultsApi.backtestResultsDeleteBacktestResult_2"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Get Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestResultsGetBacktestResult(
			resultId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<BacktestResultRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestResultsGetBacktestResult(
					resultId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"BacktestResultsApi.backtestResultsGetBacktestResult"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Get Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestResultsGetBacktestResult_3(
			resultId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<BacktestResultRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestResultsGetBacktestResult_3(
					resultId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"BacktestResultsApi.backtestResultsGetBacktestResult_3"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 해당 백테스트의 전체 결과 시점 목록 조회
		 * @summary List Backtest Results
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestResultsListBacktestResults(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<BacktestResultRead>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestResultsListBacktestResults(
					backtestId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"BacktestResultsApi.backtestResultsListBacktestResults"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 해당 백테스트의 전체 결과 시점 목록 조회
		 * @summary List Backtest Results
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestResultsListBacktestResults_4(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<BacktestResultRead>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestResultsListBacktestResults_4(
					backtestId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"BacktestResultsApi.backtestResultsListBacktestResults_4"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * BacktestResultsApi - factory interface
 * @export
 */
export const BacktestResultsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = BacktestResultsApiFp(configuration);
	return {
		/**
		 * 일자별 결과 저장 (배치/시뮬레이션 단계에서 호출 가능)
		 * @summary Create Backtest Result
		 * @param {BacktestResultCreate} backtestResultCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsCreateBacktestResult(
			backtestResultCreate: BacktestResultCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestResultRead> {
			return localVarFp
				.backtestResultsCreateBacktestResult(
					backtestResultCreate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 일자별 결과 저장 (배치/시뮬레이션 단계에서 호출 가능)
		 * @summary Create Backtest Result
		 * @param {BacktestResultCreate} backtestResultCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsCreateBacktestResult_1(
			backtestResultCreate: BacktestResultCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestResultRead> {
			return localVarFp
				.backtestResultsCreateBacktestResult_1(
					backtestResultCreate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsDeleteBacktestResult(
			resultId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.backtestResultsDeleteBacktestResult(resultId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsDeleteBacktestResult_2(
			resultId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.backtestResultsDeleteBacktestResult_2(resultId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsGetBacktestResult(
			resultId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestResultRead> {
			return localVarFp
				.backtestResultsGetBacktestResult(resultId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get Backtest Result
		 * @param {string} resultId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsGetBacktestResult_3(
			resultId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestResultRead> {
			return localVarFp
				.backtestResultsGetBacktestResult_3(resultId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 해당 백테스트의 전체 결과 시점 목록 조회
		 * @summary List Backtest Results
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsListBacktestResults(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<BacktestResultRead>> {
			return localVarFp
				.backtestResultsListBacktestResults(backtestId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 해당 백테스트의 전체 결과 시점 목록 조회
		 * @summary List Backtest Results
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestResultsListBacktestResults_4(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<BacktestResultRead>> {
			return localVarFp
				.backtestResultsListBacktestResults_4(backtestId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * BacktestResultsApi - object-oriented interface
 * @export
 * @class BacktestResultsApi
 * @extends {BaseAPI}
 */
export class BacktestResultsApi extends BaseAPI {
	/**
	 * 일자별 결과 저장 (배치/시뮬레이션 단계에서 호출 가능)
	 * @summary Create Backtest Result
	 * @param {BacktestResultCreate} backtestResultCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestResultsApi
	 */
	public backtestResultsCreateBacktestResult(
		backtestResultCreate: BacktestResultCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestResultsApiFp(this.configuration)
			.backtestResultsCreateBacktestResult(
				backtestResultCreate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 일자별 결과 저장 (배치/시뮬레이션 단계에서 호출 가능)
	 * @summary Create Backtest Result
	 * @param {BacktestResultCreate} backtestResultCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestResultsApi
	 */
	public backtestResultsCreateBacktestResult_1(
		backtestResultCreate: BacktestResultCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestResultsApiFp(this.configuration)
			.backtestResultsCreateBacktestResult_1(
				backtestResultCreate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete Backtest Result
	 * @param {string} resultId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestResultsApi
	 */
	public backtestResultsDeleteBacktestResult(
		resultId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestResultsApiFp(this.configuration)
			.backtestResultsDeleteBacktestResult(resultId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete Backtest Result
	 * @param {string} resultId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestResultsApi
	 */
	public backtestResultsDeleteBacktestResult_2(
		resultId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestResultsApiFp(this.configuration)
			.backtestResultsDeleteBacktestResult_2(resultId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get Backtest Result
	 * @param {string} resultId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestResultsApi
	 */
	public backtestResultsGetBacktestResult(
		resultId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestResultsApiFp(this.configuration)
			.backtestResultsGetBacktestResult(resultId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get Backtest Result
	 * @param {string} resultId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestResultsApi
	 */
	public backtestResultsGetBacktestResult_3(
		resultId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestResultsApiFp(this.configuration)
			.backtestResultsGetBacktestResult_3(resultId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 해당 백테스트의 전체 결과 시점 목록 조회
	 * @summary List Backtest Results
	 * @param {string} backtestId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestResultsApi
	 */
	public backtestResultsListBacktestResults(
		backtestId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestResultsApiFp(this.configuration)
			.backtestResultsListBacktestResults(backtestId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 해당 백테스트의 전체 결과 시점 목록 조회
	 * @summary List Backtest Results
	 * @param {string} backtestId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestResultsApi
	 */
	public backtestResultsListBacktestResults_4(
		backtestId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestResultsApiFp(this.configuration)
			.backtestResultsListBacktestResults_4(backtestId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * BacktestsApi - axios parameter creator
 * @export
 */
export const BacktestsApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary Create Backtest
		 * @param {BacktestCreate} backtestCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsCreateBacktest: async (
			backtestCreate: BacktestCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestCreate' is not null or undefined
			assertParamExists(
				"backtestsCreateBacktest",
				"backtestCreate",
				backtestCreate,
			);
			const localVarPath = `/api/v1/backtests/backtests/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				backtestCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Create Backtest
		 * @param {BacktestCreate} backtestCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsCreateBacktest_1: async (
			backtestCreate: BacktestCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestCreate' is not null or undefined
			assertParamExists(
				"backtestsCreateBacktest_1",
				"backtestCreate",
				backtestCreate,
			);
			const localVarPath = `/api/v1/backtests/backtests/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				backtestCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsDeleteBacktest: async (
			backtestId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists("backtestsDeleteBacktest", "backtestId", backtestId);
			const localVarPath = `/api/v1/backtests/backtests/{backtest_id}`.replace(
				`{${"backtest_id"}}`,
				encodeURIComponent(String(backtestId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsDeleteBacktest_2: async (
			backtestId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists("backtestsDeleteBacktest_2", "backtestId", backtestId);
			const localVarPath = `/api/v1/backtests/backtests/{backtest_id}`.replace(
				`{${"backtest_id"}}`,
				encodeURIComponent(String(backtestId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsGetBacktest: async (
			backtestId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists("backtestsGetBacktest", "backtestId", backtestId);
			const localVarPath = `/api/v1/backtests/backtests/{backtest_id}`.replace(
				`{${"backtest_id"}}`,
				encodeURIComponent(String(backtestId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsGetBacktest_3: async (
			backtestId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists("backtestsGetBacktest_3", "backtestId", backtestId);
			const localVarPath = `/api/v1/backtests/backtests/{backtest_id}`.replace(
				`{${"backtest_id"}}`,
				encodeURIComponent(String(backtestId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary List Backtests
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsListBacktests: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/backtests/backtests/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary List Backtests
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsListBacktests_4: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/backtests/backtests/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 실제 백테스트 시뮬레이션 (동기/비동기) 예시
		 * @summary Run Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsRunBacktest: async (
			backtestId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists("backtestsRunBacktest", "backtestId", backtestId);
			const localVarPath =
				`/api/v1/backtests/backtests/{backtest_id}/run`.replace(
					`{${"backtest_id"}}`,
					encodeURIComponent(String(backtestId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 실제 백테스트 시뮬레이션 (동기/비동기) 예시
		 * @summary Run Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsRunBacktest_5: async (
			backtestId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists("backtestsRunBacktest_5", "backtestId", backtestId);
			const localVarPath =
				`/api/v1/backtests/backtests/{backtest_id}/run`.replace(
					`{${"backtest_id"}}`,
					encodeURIComponent(String(backtestId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update Backtest
		 * @param {string} backtestId
		 * @param {BacktestUpdate} backtestUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsUpdateBacktest: async (
			backtestId: string,
			backtestUpdate: BacktestUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists("backtestsUpdateBacktest", "backtestId", backtestId);
			// verify required parameter 'backtestUpdate' is not null or undefined
			assertParamExists(
				"backtestsUpdateBacktest",
				"backtestUpdate",
				backtestUpdate,
			);
			const localVarPath = `/api/v1/backtests/backtests/{backtest_id}`.replace(
				`{${"backtest_id"}}`,
				encodeURIComponent(String(backtestId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				backtestUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update Backtest
		 * @param {string} backtestId
		 * @param {BacktestUpdate} backtestUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsUpdateBacktest_6: async (
			backtestId: string,
			backtestUpdate: BacktestUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'backtestId' is not null or undefined
			assertParamExists("backtestsUpdateBacktest_6", "backtestId", backtestId);
			// verify required parameter 'backtestUpdate' is not null or undefined
			assertParamExists(
				"backtestsUpdateBacktest_6",
				"backtestUpdate",
				backtestUpdate,
			);
			const localVarPath = `/api/v1/backtests/backtests/{backtest_id}`.replace(
				`{${"backtest_id"}}`,
				encodeURIComponent(String(backtestId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				backtestUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * BacktestsApi - functional programming interface
 * @export
 */
export const BacktestsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		BacktestsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Create Backtest
		 * @param {BacktestCreate} backtestCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsCreateBacktest(
			backtestCreate: BacktestCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BacktestRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsCreateBacktest(
					backtestCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsCreateBacktest"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Create Backtest
		 * @param {BacktestCreate} backtestCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsCreateBacktest_1(
			backtestCreate: BacktestCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BacktestRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsCreateBacktest_1(
					backtestCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsCreateBacktest_1"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Delete Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsDeleteBacktest(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsDeleteBacktest(
					backtestId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsDeleteBacktest"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Delete Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsDeleteBacktest_2(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsDeleteBacktest_2(
					backtestId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsDeleteBacktest_2"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Get Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsGetBacktest(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BacktestRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsGetBacktest(
					backtestId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsGetBacktest"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Get Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsGetBacktest_3(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BacktestRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsGetBacktest_3(
					backtestId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsGetBacktest_3"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary List Backtests
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsListBacktests(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<BacktestRead>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsListBacktests(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsListBacktests"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary List Backtests
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsListBacktests_4(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<BacktestRead>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsListBacktests_4(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsListBacktests_4"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 실제 백테스트 시뮬레이션 (동기/비동기) 예시
		 * @summary Run Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsRunBacktest(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsRunBacktest(
					backtestId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsRunBacktest"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 실제 백테스트 시뮬레이션 (동기/비동기) 예시
		 * @summary Run Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsRunBacktest_5(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsRunBacktest_5(
					backtestId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsRunBacktest_5"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Update Backtest
		 * @param {string} backtestId
		 * @param {BacktestUpdate} backtestUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsUpdateBacktest(
			backtestId: string,
			backtestUpdate: BacktestUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BacktestRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsUpdateBacktest(
					backtestId,
					backtestUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsUpdateBacktest"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Update Backtest
		 * @param {string} backtestId
		 * @param {BacktestUpdate} backtestUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async backtestsUpdateBacktest_6(
			backtestId: string,
			backtestUpdate: BacktestUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BacktestRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.backtestsUpdateBacktest_6(
					backtestId,
					backtestUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["BacktestsApi.backtestsUpdateBacktest_6"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * BacktestsApi - factory interface
 * @export
 */
export const BacktestsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = BacktestsApiFp(configuration);
	return {
		/**
		 *
		 * @summary Create Backtest
		 * @param {BacktestCreate} backtestCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsCreateBacktest(
			backtestCreate: BacktestCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestRead> {
			return localVarFp
				.backtestsCreateBacktest(backtestCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Create Backtest
		 * @param {BacktestCreate} backtestCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsCreateBacktest_1(
			backtestCreate: BacktestCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestRead> {
			return localVarFp
				.backtestsCreateBacktest_1(backtestCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsDeleteBacktest(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.backtestsDeleteBacktest(backtestId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsDeleteBacktest_2(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.backtestsDeleteBacktest_2(backtestId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsGetBacktest(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestRead> {
			return localVarFp
				.backtestsGetBacktest(backtestId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsGetBacktest_3(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestRead> {
			return localVarFp
				.backtestsGetBacktest_3(backtestId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary List Backtests
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsListBacktests(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<BacktestRead>> {
			return localVarFp
				.backtestsListBacktests(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary List Backtests
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsListBacktests_4(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<BacktestRead>> {
			return localVarFp
				.backtestsListBacktests_4(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 실제 백테스트 시뮬레이션 (동기/비동기) 예시
		 * @summary Run Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsRunBacktest(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.backtestsRunBacktest(backtestId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 실제 백테스트 시뮬레이션 (동기/비동기) 예시
		 * @summary Run Backtest
		 * @param {string} backtestId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsRunBacktest_5(
			backtestId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.backtestsRunBacktest_5(backtestId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update Backtest
		 * @param {string} backtestId
		 * @param {BacktestUpdate} backtestUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsUpdateBacktest(
			backtestId: string,
			backtestUpdate: BacktestUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestRead> {
			return localVarFp
				.backtestsUpdateBacktest(
					backtestId,
					backtestUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update Backtest
		 * @param {string} backtestId
		 * @param {BacktestUpdate} backtestUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		backtestsUpdateBacktest_6(
			backtestId: string,
			backtestUpdate: BacktestUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<BacktestRead> {
			return localVarFp
				.backtestsUpdateBacktest_6(
					backtestId,
					backtestUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * BacktestsApi - object-oriented interface
 * @export
 * @class BacktestsApi
 * @extends {BaseAPI}
 */
export class BacktestsApi extends BaseAPI {
	/**
	 *
	 * @summary Create Backtest
	 * @param {BacktestCreate} backtestCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsCreateBacktest(
		backtestCreate: BacktestCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsCreateBacktest(backtestCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Create Backtest
	 * @param {BacktestCreate} backtestCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsCreateBacktest_1(
		backtestCreate: BacktestCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsCreateBacktest_1(backtestCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete Backtest
	 * @param {string} backtestId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsDeleteBacktest(
		backtestId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsDeleteBacktest(backtestId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete Backtest
	 * @param {string} backtestId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsDeleteBacktest_2(
		backtestId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsDeleteBacktest_2(backtestId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get Backtest
	 * @param {string} backtestId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsGetBacktest(
		backtestId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsGetBacktest(backtestId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get Backtest
	 * @param {string} backtestId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsGetBacktest_3(
		backtestId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsGetBacktest_3(backtestId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary List Backtests
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsListBacktests(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsListBacktests(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary List Backtests
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsListBacktests_4(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsListBacktests_4(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 실제 백테스트 시뮬레이션 (동기/비동기) 예시
	 * @summary Run Backtest
	 * @param {string} backtestId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsRunBacktest(
		backtestId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsRunBacktest(backtestId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 실제 백테스트 시뮬레이션 (동기/비동기) 예시
	 * @summary Run Backtest
	 * @param {string} backtestId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsRunBacktest_5(
		backtestId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsRunBacktest_5(backtestId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update Backtest
	 * @param {string} backtestId
	 * @param {BacktestUpdate} backtestUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsUpdateBacktest(
		backtestId: string,
		backtestUpdate: BacktestUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsUpdateBacktest(backtestId, backtestUpdate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update Backtest
	 * @param {string} backtestId
	 * @param {BacktestUpdate} backtestUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BacktestsApi
	 */
	public backtestsUpdateBacktest_6(
		backtestId: string,
		backtestUpdate: BacktestUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return BacktestsApiFp(this.configuration)
			.backtestsUpdateBacktest_6(
				backtestId,
				backtestUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * StrategiesApi - axios parameter creator
 * @export
 */
export const StrategiesApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 *
		 * @summary Create Strategy
		 * @param {StrategyCreate} strategyCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesCreateStrategy: async (
			strategyCreate: StrategyCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'strategyCreate' is not null or undefined
			assertParamExists(
				"strategiesCreateStrategy",
				"strategyCreate",
				strategyCreate,
			);
			const localVarPath = `/api/v1/strategies/strategies/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				strategyCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Create Strategy
		 * @param {StrategyCreate} strategyCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesCreateStrategy_1: async (
			strategyCreate: StrategyCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'strategyCreate' is not null or undefined
			assertParamExists(
				"strategiesCreateStrategy_1",
				"strategyCreate",
				strategyCreate,
			);
			const localVarPath = `/api/v1/strategies/strategies/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				strategyCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesDeleteStrategy: async (
			strategyId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'strategyId' is not null or undefined
			assertParamExists("strategiesDeleteStrategy", "strategyId", strategyId);
			const localVarPath =
				`/api/v1/strategies/strategies/{strategy_id}`.replace(
					`{${"strategy_id"}}`,
					encodeURIComponent(String(strategyId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Delete Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesDeleteStrategy_2: async (
			strategyId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'strategyId' is not null or undefined
			assertParamExists("strategiesDeleteStrategy_2", "strategyId", strategyId);
			const localVarPath =
				`/api/v1/strategies/strategies/{strategy_id}`.replace(
					`{${"strategy_id"}}`,
					encodeURIComponent(String(strategyId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesGetStrategy: async (
			strategyId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'strategyId' is not null or undefined
			assertParamExists("strategiesGetStrategy", "strategyId", strategyId);
			const localVarPath =
				`/api/v1/strategies/strategies/{strategy_id}`.replace(
					`{${"strategy_id"}}`,
					encodeURIComponent(String(strategyId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Get Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesGetStrategy_3: async (
			strategyId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'strategyId' is not null or undefined
			assertParamExists("strategiesGetStrategy_3", "strategyId", strategyId);
			const localVarPath =
				`/api/v1/strategies/strategies/{strategy_id}`.replace(
					`{${"strategy_id"}}`,
					encodeURIComponent(String(strategyId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary List Strategies
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesListStrategies: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/strategies/strategies/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary List Strategies
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesListStrategies_4: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/strategies/strategies/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update Strategy
		 * @param {string} strategyId
		 * @param {StrategyUpdate} strategyUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesUpdateStrategy: async (
			strategyId: string,
			strategyUpdate: StrategyUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'strategyId' is not null or undefined
			assertParamExists("strategiesUpdateStrategy", "strategyId", strategyId);
			// verify required parameter 'strategyUpdate' is not null or undefined
			assertParamExists(
				"strategiesUpdateStrategy",
				"strategyUpdate",
				strategyUpdate,
			);
			const localVarPath =
				`/api/v1/strategies/strategies/{strategy_id}`.replace(
					`{${"strategy_id"}}`,
					encodeURIComponent(String(strategyId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				strategyUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @summary Update Strategy
		 * @param {string} strategyId
		 * @param {StrategyUpdate} strategyUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesUpdateStrategy_5: async (
			strategyId: string,
			strategyUpdate: StrategyUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'strategyId' is not null or undefined
			assertParamExists("strategiesUpdateStrategy_5", "strategyId", strategyId);
			// verify required parameter 'strategyUpdate' is not null or undefined
			assertParamExists(
				"strategiesUpdateStrategy_5",
				"strategyUpdate",
				strategyUpdate,
			);
			const localVarPath =
				`/api/v1/strategies/strategies/{strategy_id}`.replace(
					`{${"strategy_id"}}`,
					encodeURIComponent(String(strategyId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				strategyUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * StrategiesApi - functional programming interface
 * @export
 */
export const StrategiesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		StrategiesApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @summary Create Strategy
		 * @param {StrategyCreate} strategyCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesCreateStrategy(
			strategyCreate: StrategyCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesCreateStrategy(
					strategyCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesCreateStrategy"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Create Strategy
		 * @param {StrategyCreate} strategyCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesCreateStrategy_1(
			strategyCreate: StrategyCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesCreateStrategy_1(
					strategyCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesCreateStrategy_1"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Delete Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesDeleteStrategy(
			strategyId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesDeleteStrategy(
					strategyId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesDeleteStrategy"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Delete Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesDeleteStrategy_2(
			strategyId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesDeleteStrategy_2(
					strategyId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesDeleteStrategy_2"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Get Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesGetStrategy(
			strategyId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesGetStrategy(
					strategyId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesGetStrategy"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Get Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesGetStrategy_3(
			strategyId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesGetStrategy_3(
					strategyId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesGetStrategy_3"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary List Strategies
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesListStrategies(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<StrategyRead>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesListStrategies(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesListStrategies"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary List Strategies
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesListStrategies_4(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<StrategyRead>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesListStrategies_4(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesListStrategies_4"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Update Strategy
		 * @param {string} strategyId
		 * @param {StrategyUpdate} strategyUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesUpdateStrategy(
			strategyId: string,
			strategyUpdate: StrategyUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesUpdateStrategy(
					strategyId,
					strategyUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesUpdateStrategy"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 *
		 * @summary Update Strategy
		 * @param {string} strategyId
		 * @param {StrategyUpdate} strategyUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async strategiesUpdateStrategy_5(
			strategyId: string,
			strategyUpdate: StrategyUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StrategyRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.strategiesUpdateStrategy_5(
					strategyId,
					strategyUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["StrategiesApi.strategiesUpdateStrategy_5"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * StrategiesApi - factory interface
 * @export
 */
export const StrategiesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = StrategiesApiFp(configuration);
	return {
		/**
		 *
		 * @summary Create Strategy
		 * @param {StrategyCreate} strategyCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesCreateStrategy(
			strategyCreate: StrategyCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<StrategyRead> {
			return localVarFp
				.strategiesCreateStrategy(strategyCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Create Strategy
		 * @param {StrategyCreate} strategyCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesCreateStrategy_1(
			strategyCreate: StrategyCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<StrategyRead> {
			return localVarFp
				.strategiesCreateStrategy_1(strategyCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesDeleteStrategy(
			strategyId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.strategiesDeleteStrategy(strategyId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Delete Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesDeleteStrategy_2(
			strategyId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.strategiesDeleteStrategy_2(strategyId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesGetStrategy(
			strategyId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<StrategyRead> {
			return localVarFp
				.strategiesGetStrategy(strategyId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Get Strategy
		 * @param {string} strategyId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesGetStrategy_3(
			strategyId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<StrategyRead> {
			return localVarFp
				.strategiesGetStrategy_3(strategyId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary List Strategies
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesListStrategies(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<StrategyRead>> {
			return localVarFp
				.strategiesListStrategies(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary List Strategies
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesListStrategies_4(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<StrategyRead>> {
			return localVarFp
				.strategiesListStrategies_4(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update Strategy
		 * @param {string} strategyId
		 * @param {StrategyUpdate} strategyUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesUpdateStrategy(
			strategyId: string,
			strategyUpdate: StrategyUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<StrategyRead> {
			return localVarFp
				.strategiesUpdateStrategy(
					strategyId,
					strategyUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @summary Update Strategy
		 * @param {string} strategyId
		 * @param {StrategyUpdate} strategyUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		strategiesUpdateStrategy_5(
			strategyId: string,
			strategyUpdate: StrategyUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<StrategyRead> {
			return localVarFp
				.strategiesUpdateStrategy_5(
					strategyId,
					strategyUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * StrategiesApi - object-oriented interface
 * @export
 * @class StrategiesApi
 * @extends {BaseAPI}
 */
export class StrategiesApi extends BaseAPI {
	/**
	 *
	 * @summary Create Strategy
	 * @param {StrategyCreate} strategyCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesCreateStrategy(
		strategyCreate: StrategyCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesCreateStrategy(strategyCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Create Strategy
	 * @param {StrategyCreate} strategyCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesCreateStrategy_1(
		strategyCreate: StrategyCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesCreateStrategy_1(strategyCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete Strategy
	 * @param {string} strategyId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesDeleteStrategy(
		strategyId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesDeleteStrategy(strategyId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Delete Strategy
	 * @param {string} strategyId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesDeleteStrategy_2(
		strategyId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesDeleteStrategy_2(strategyId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get Strategy
	 * @param {string} strategyId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesGetStrategy(
		strategyId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesGetStrategy(strategyId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Get Strategy
	 * @param {string} strategyId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesGetStrategy_3(
		strategyId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesGetStrategy_3(strategyId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary List Strategies
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesListStrategies(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesListStrategies(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary List Strategies
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesListStrategies_4(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesListStrategies_4(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update Strategy
	 * @param {string} strategyId
	 * @param {StrategyUpdate} strategyUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesUpdateStrategy(
		strategyId: string,
		strategyUpdate: StrategyUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesUpdateStrategy(
				strategyId,
				strategyUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @summary Update Strategy
	 * @param {string} strategyId
	 * @param {StrategyUpdate} strategyUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StrategiesApi
	 */
	public strategiesUpdateStrategy_5(
		strategyId: string,
		strategyUpdate: StrategyUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return StrategiesApiFp(this.configuration)
			.strategiesUpdateStrategy_5(
				strategyId,
				strategyUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * WatchlistsApi - axios parameter creator
 * @export
 */
export const WatchlistsApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * 워치리스트에 단일 종목(symbol) 추가
		 * @summary Add Asset To Watchlist
		 * @param {string} watchlistId
		 * @param {string} symbol
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsAddAssetToWatchlist: async (
			watchlistId: string,
			symbol: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'watchlistId' is not null or undefined
			assertParamExists(
				"watchlistsAddAssetToWatchlist",
				"watchlistId",
				watchlistId,
			);
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("watchlistsAddAssetToWatchlist", "symbol", symbol);
			const localVarPath = `/api/v1/watchlists/{watchlist_id}/assets`.replace(
				`{${"watchlist_id"}}`,
				encodeURIComponent(String(watchlistId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 새로운 워치리스트 생성
		 * @summary Create Watchlist
		 * @param {WatchlistCreate} watchlistCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsCreateWatchlist: async (
			watchlistCreate: WatchlistCreate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'watchlistCreate' is not null or undefined
			assertParamExists(
				"watchlistsCreateWatchlist",
				"watchlistCreate",
				watchlistCreate,
			);
			const localVarPath = `/api/v1/watchlists/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				watchlistCreate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 워치리스트 소프트 삭제 (deleted=True)
		 * @summary Delete Watchlist
		 * @param {string} watchlistId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsDeleteWatchlist: async (
			watchlistId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'watchlistId' is not null or undefined
			assertParamExists(
				"watchlistsDeleteWatchlist",
				"watchlistId",
				watchlistId,
			);
			const localVarPath = `/api/v1/watchlists/{watchlist_id}`.replace(
				`{${"watchlist_id"}}`,
				encodeURIComponent(String(watchlistId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 단일 워치리스트 상세 조회
		 * @summary Get Watchlist
		 * @param {string} watchlistId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsGetWatchlist: async (
			watchlistId: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'watchlistId' is not null or undefined
			assertParamExists("watchlistsGetWatchlist", "watchlistId", watchlistId);
			const localVarPath = `/api/v1/watchlists/{watchlist_id}`.replace(
				`{${"watchlist_id"}}`,
				encodeURIComponent(String(watchlistId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 사용자의 모든 워치리스트 조회 (deleted=False만)
		 * @summary List Watchlists
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsListWatchlists: async (
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			const localVarPath = `/api/v1/watchlists/`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 워치리스트에서 단일 종목 제거
		 * @summary Remove Asset From Watchlist
		 * @param {string} watchlistId
		 * @param {string} symbol
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsRemoveAssetFromWatchlist: async (
			watchlistId: string,
			symbol: string,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'watchlistId' is not null or undefined
			assertParamExists(
				"watchlistsRemoveAssetFromWatchlist",
				"watchlistId",
				watchlistId,
			);
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("watchlistsRemoveAssetFromWatchlist", "symbol", symbol);
			const localVarPath = `/api/v1/watchlists/{watchlist_id}/assets/{symbol}`
				.replace(`{${"watchlist_id"}}`, encodeURIComponent(String(watchlistId)))
				.replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "DELETE",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Watchlist 내 모든 symbol에 대해, 최근 N일치 시세를 가져와 MarketData 컬렉션에 저장
		 * @summary Sync Market Data For Watchlist
		 * @param {string} watchlistId
		 * @param {number} [days]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsSyncMarketDataForWatchlist: async (
			watchlistId: string,
			days?: number,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'watchlistId' is not null or undefined
			assertParamExists(
				"watchlistsSyncMarketDataForWatchlist",
				"watchlistId",
				watchlistId,
			);
			const localVarPath =
				`/api/v1/watchlists/{watchlist_id}/sync-market-data`.replace(
					`{${"watchlist_id"}}`,
					encodeURIComponent(String(watchlistId)),
				);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "POST",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			if (days !== undefined) {
				localVarQueryParameter["days"] = days;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * 워치리스트 정보 수정 (name, description, 전체 assets 등)
		 * @summary Update Watchlist
		 * @param {string} watchlistId
		 * @param {WatchlistUpdate} watchlistUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsUpdateWatchlist: async (
			watchlistId: string,
			watchlistUpdate: WatchlistUpdate,
			accessToken?: string | null,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'watchlistId' is not null or undefined
			assertParamExists(
				"watchlistsUpdateWatchlist",
				"watchlistId",
				watchlistId,
			);
			// verify required parameter 'watchlistUpdate' is not null or undefined
			assertParamExists(
				"watchlistsUpdateWatchlist",
				"watchlistUpdate",
				watchlistUpdate,
			);
			const localVarPath = `/api/v1/watchlists/{watchlist_id}`.replace(
				`{${"watchlist_id"}}`,
				encodeURIComponent(String(watchlistId)),
			);
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "PUT",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			// authentication OAuth2PasswordBearer required
			// oauth required
			await setOAuthToObject(
				localVarHeaderParameter,
				"OAuth2PasswordBearer",
				[],
				configuration,
			);

			localVarHeaderParameter["Content-Type"] = "application/json";

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};
			localVarRequestOptions.data = serializeDataIfNeeded(
				watchlistUpdate,
				localVarRequestOptions,
				configuration,
			);

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * WatchlistsApi - functional programming interface
 * @export
 */
export const WatchlistsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		WatchlistsApiAxiosParamCreator(configuration);
	return {
		/**
		 * 워치리스트에 단일 종목(symbol) 추가
		 * @summary Add Asset To Watchlist
		 * @param {string} watchlistId
		 * @param {string} symbol
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async watchlistsAddAssetToWatchlist(
			watchlistId: string,
			symbol: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.watchlistsAddAssetToWatchlist(
					watchlistId,
					symbol,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WatchlistsApi.watchlistsAddAssetToWatchlist"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 새로운 워치리스트 생성
		 * @summary Create Watchlist
		 * @param {WatchlistCreate} watchlistCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async watchlistsCreateWatchlist(
			watchlistCreate: WatchlistCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.watchlistsCreateWatchlist(
					watchlistCreate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WatchlistsApi.watchlistsCreateWatchlist"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 워치리스트 소프트 삭제 (deleted=True)
		 * @summary Delete Watchlist
		 * @param {string} watchlistId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async watchlistsDeleteWatchlist(
			watchlistId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.watchlistsDeleteWatchlist(
					watchlistId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WatchlistsApi.watchlistsDeleteWatchlist"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 단일 워치리스트 상세 조회
		 * @summary Get Watchlist
		 * @param {string} watchlistId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async watchlistsGetWatchlist(
			watchlistId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.watchlistsGetWatchlist(
					watchlistId,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WatchlistsApi.watchlistsGetWatchlist"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 사용자의 모든 워치리스트 조회 (deleted=False만)
		 * @summary List Watchlists
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async watchlistsListWatchlists(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string,
			) => AxiosPromise<Array<WatchlistRead>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.watchlistsListWatchlists(
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WatchlistsApi.watchlistsListWatchlists"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 워치리스트에서 단일 종목 제거
		 * @summary Remove Asset From Watchlist
		 * @param {string} watchlistId
		 * @param {string} symbol
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async watchlistsRemoveAssetFromWatchlist(
			watchlistId: string,
			symbol: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.watchlistsRemoveAssetFromWatchlist(
					watchlistId,
					symbol,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"WatchlistsApi.watchlistsRemoveAssetFromWatchlist"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Watchlist 내 모든 symbol에 대해, 최근 N일치 시세를 가져와 MarketData 컬렉션에 저장
		 * @summary Sync Market Data For Watchlist
		 * @param {string} watchlistId
		 * @param {number} [days]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async watchlistsSyncMarketDataForWatchlist(
			watchlistId: string,
			days?: number,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.watchlistsSyncMarketDataForWatchlist(
					watchlistId,
					days,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"WatchlistsApi.watchlistsSyncMarketDataForWatchlist"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * 워치리스트 정보 수정 (name, description, 전체 assets 등)
		 * @summary Update Watchlist
		 * @param {string} watchlistId
		 * @param {WatchlistUpdate} watchlistUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async watchlistsUpdateWatchlist(
			watchlistId: string,
			watchlistUpdate: WatchlistUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchlistRead>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.watchlistsUpdateWatchlist(
					watchlistId,
					watchlistUpdate,
					accessToken,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["WatchlistsApi.watchlistsUpdateWatchlist"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * WatchlistsApi - factory interface
 * @export
 */
export const WatchlistsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = WatchlistsApiFp(configuration);
	return {
		/**
		 * 워치리스트에 단일 종목(symbol) 추가
		 * @summary Add Asset To Watchlist
		 * @param {string} watchlistId
		 * @param {string} symbol
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsAddAssetToWatchlist(
			watchlistId: string,
			symbol: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<any> {
			return localVarFp
				.watchlistsAddAssetToWatchlist(
					watchlistId,
					symbol,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 새로운 워치리스트 생성
		 * @summary Create Watchlist
		 * @param {WatchlistCreate} watchlistCreate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsCreateWatchlist(
			watchlistCreate: WatchlistCreate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<WatchlistRead> {
			return localVarFp
				.watchlistsCreateWatchlist(watchlistCreate, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 워치리스트 소프트 삭제 (deleted=True)
		 * @summary Delete Watchlist
		 * @param {string} watchlistId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsDeleteWatchlist(
			watchlistId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.watchlistsDeleteWatchlist(watchlistId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 단일 워치리스트 상세 조회
		 * @summary Get Watchlist
		 * @param {string} watchlistId
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsGetWatchlist(
			watchlistId: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<WatchlistRead> {
			return localVarFp
				.watchlistsGetWatchlist(watchlistId, accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 사용자의 모든 워치리스트 조회 (deleted=False만)
		 * @summary List Watchlists
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsListWatchlists(
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Array<WatchlistRead>> {
			return localVarFp
				.watchlistsListWatchlists(accessToken, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 워치리스트에서 단일 종목 제거
		 * @summary Remove Asset From Watchlist
		 * @param {string} watchlistId
		 * @param {string} symbol
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsRemoveAssetFromWatchlist(
			watchlistId: string,
			symbol: string,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.watchlistsRemoveAssetFromWatchlist(
					watchlistId,
					symbol,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Watchlist 내 모든 symbol에 대해, 최근 N일치 시세를 가져와 MarketData 컬렉션에 저장
		 * @summary Sync Market Data For Watchlist
		 * @param {string} watchlistId
		 * @param {number} [days]
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsSyncMarketDataForWatchlist(
			watchlistId: string,
			days?: number,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<Message> {
			return localVarFp
				.watchlistsSyncMarketDataForWatchlist(
					watchlistId,
					days,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
		/**
		 * 워치리스트 정보 수정 (name, description, 전체 assets 등)
		 * @summary Update Watchlist
		 * @param {string} watchlistId
		 * @param {WatchlistUpdate} watchlistUpdate
		 * @param {string | null} [accessToken]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		watchlistsUpdateWatchlist(
			watchlistId: string,
			watchlistUpdate: WatchlistUpdate,
			accessToken?: string | null,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<WatchlistRead> {
			return localVarFp
				.watchlistsUpdateWatchlist(
					watchlistId,
					watchlistUpdate,
					accessToken,
					options,
				)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * WatchlistsApi - object-oriented interface
 * @export
 * @class WatchlistsApi
 * @extends {BaseAPI}
 */
export class WatchlistsApi extends BaseAPI {
	/**
	 * 워치리스트에 단일 종목(symbol) 추가
	 * @summary Add Asset To Watchlist
	 * @param {string} watchlistId
	 * @param {string} symbol
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WatchlistsApi
	 */
	public watchlistsAddAssetToWatchlist(
		watchlistId: string,
		symbol: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return WatchlistsApiFp(this.configuration)
			.watchlistsAddAssetToWatchlist(watchlistId, symbol, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 새로운 워치리스트 생성
	 * @summary Create Watchlist
	 * @param {WatchlistCreate} watchlistCreate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WatchlistsApi
	 */
	public watchlistsCreateWatchlist(
		watchlistCreate: WatchlistCreate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return WatchlistsApiFp(this.configuration)
			.watchlistsCreateWatchlist(watchlistCreate, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 워치리스트 소프트 삭제 (deleted=True)
	 * @summary Delete Watchlist
	 * @param {string} watchlistId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WatchlistsApi
	 */
	public watchlistsDeleteWatchlist(
		watchlistId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return WatchlistsApiFp(this.configuration)
			.watchlistsDeleteWatchlist(watchlistId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 단일 워치리스트 상세 조회
	 * @summary Get Watchlist
	 * @param {string} watchlistId
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WatchlistsApi
	 */
	public watchlistsGetWatchlist(
		watchlistId: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return WatchlistsApiFp(this.configuration)
			.watchlistsGetWatchlist(watchlistId, accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 사용자의 모든 워치리스트 조회 (deleted=False만)
	 * @summary List Watchlists
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WatchlistsApi
	 */
	public watchlistsListWatchlists(
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return WatchlistsApiFp(this.configuration)
			.watchlistsListWatchlists(accessToken, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 워치리스트에서 단일 종목 제거
	 * @summary Remove Asset From Watchlist
	 * @param {string} watchlistId
	 * @param {string} symbol
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WatchlistsApi
	 */
	public watchlistsRemoveAssetFromWatchlist(
		watchlistId: string,
		symbol: string,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return WatchlistsApiFp(this.configuration)
			.watchlistsRemoveAssetFromWatchlist(
				watchlistId,
				symbol,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Watchlist 내 모든 symbol에 대해, 최근 N일치 시세를 가져와 MarketData 컬렉션에 저장
	 * @summary Sync Market Data For Watchlist
	 * @param {string} watchlistId
	 * @param {number} [days]
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WatchlistsApi
	 */
	public watchlistsSyncMarketDataForWatchlist(
		watchlistId: string,
		days?: number,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return WatchlistsApiFp(this.configuration)
			.watchlistsSyncMarketDataForWatchlist(
				watchlistId,
				days,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * 워치리스트 정보 수정 (name, description, 전체 assets 등)
	 * @summary Update Watchlist
	 * @param {string} watchlistId
	 * @param {WatchlistUpdate} watchlistUpdate
	 * @param {string | null} [accessToken]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WatchlistsApi
	 */
	public watchlistsUpdateWatchlist(
		watchlistId: string,
		watchlistUpdate: WatchlistUpdate,
		accessToken?: string | null,
		options?: RawAxiosRequestConfig,
	) {
		return WatchlistsApiFp(this.configuration)
			.watchlistsUpdateWatchlist(
				watchlistId,
				watchlistUpdate,
				accessToken,
				options,
			)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * YahooFinanceApi - axios parameter creator
 * @export
 */
export const YahooFinanceApiAxiosParamCreator = function (
	configuration?: Configuration,
) {
	return {
		/**
		 * Get actions of a stock
		 * @summary Get Actions
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetActions: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetActions", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/actions`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get balance sheet of a stock
		 * @summary Get Balance Sheet
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetBalanceSheet: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetBalanceSheet", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/balance-sheet`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get cashflow of a stock
		 * @summary Get Cashflow
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetCashflow: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetCashflow", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/cashflow`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get company overview of a stock
		 * @summary Get Company Overview
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetCompanyOverview: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetCompanyOverview", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/overview`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get dividends of a stock
		 * @summary Get Dividends
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetDividends: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetDividends", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/dividends`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get earnings of a stock
		 * @summary Get Earnings
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetEarnings: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetEarnings", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/earning`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get earnings calendar of a stock
		 * @summary Get Earnings Calendar
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetEarningsCalendar: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetEarningsCalendar", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/earning_calendar`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get financials of a stock
		 * @summary Get Financials
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetFinancials: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetFinancials", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/financials`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get stock history of a stock
		 * @summary Get History
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetHistory: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetHistory", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/history`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get info of a stock
		 * @summary Get Info
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetInfo: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetInfo", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/info`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get institutional holders of a stock
		 * @summary Get Institutional Holders
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetInstitutionalHolders: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists(
				"yahooFinanceGetInstitutionalHolders",
				"symbol",
				symbol,
			);
			const localVarPath = `/api/v1/yahoo/institutional-holders`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get major holders of a stock
		 * @summary Get Major Holders
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetMajorHolders: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetMajorHolders", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/major-holders`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get mutual fund holders of a stock
		 * @summary Get Mutualfund Holders
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetMutualfundHolders: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetMutualfundHolders", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/mutualfund-holders`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get options of a stock
		 * @summary Get Options
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetOptions: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetOptions", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/options`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get stock price of a stock
		 * @summary Get Price
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetPrice: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetPrice", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/price`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get quote of a stock
		 * @summary Get Quote
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetQuote: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetQuote", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/quote`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get recommendations of a stock
		 * @summary Get Recommendations
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetRecommendations: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetRecommendations", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/recommendations`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get splits of a stock
		 * @summary Get Splits
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetSplits: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetSplits", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/splits`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 * Get sustainability of a stock
		 * @summary Get Sustainability
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetSustainability: async (
			symbol: string,
			options: RawAxiosRequestConfig = {},
		): Promise<RequestArgs> => {
			// verify required parameter 'symbol' is not null or undefined
			assertParamExists("yahooFinanceGetSustainability", "symbol", symbol);
			const localVarPath = `/api/v1/yahoo/sustainability`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = {
				method: "GET",
				...baseOptions,
				...options,
			};
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (symbol !== undefined) {
				localVarQueryParameter["symbol"] = symbol;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			};

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * YahooFinanceApi - functional programming interface
 * @export
 */
export const YahooFinanceApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		YahooFinanceApiAxiosParamCreator(configuration);
	return {
		/**
		 * Get actions of a stock
		 * @summary Get Actions
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetActions(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetActions(symbol, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetActions"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get balance sheet of a stock
		 * @summary Get Balance Sheet
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetBalanceSheet(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetBalanceSheet(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetBalanceSheet"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get cashflow of a stock
		 * @summary Get Cashflow
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetCashflow(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetCashflow(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetCashflow"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get company overview of a stock
		 * @summary Get Company Overview
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetCompanyOverview(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetCompanyOverview(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetCompanyOverview"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get dividends of a stock
		 * @summary Get Dividends
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetDividends(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetDividends(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetDividends"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get earnings of a stock
		 * @summary Get Earnings
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetEarnings(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetEarnings(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetEarnings"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get earnings calendar of a stock
		 * @summary Get Earnings Calendar
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetEarningsCalendar(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetEarningsCalendar(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetEarningsCalendar"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get financials of a stock
		 * @summary Get Financials
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetFinancials(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetFinancials(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetFinancials"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get stock history of a stock
		 * @summary Get History
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetHistory(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetHistory(symbol, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetHistory"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get info of a stock
		 * @summary Get Info
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetInfo(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetInfo(symbol, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetInfo"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get institutional holders of a stock
		 * @summary Get Institutional Holders
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetInstitutionalHolders(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetInstitutionalHolders(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"YahooFinanceApi.yahooFinanceGetInstitutionalHolders"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get major holders of a stock
		 * @summary Get Major Holders
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetMajorHolders(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetMajorHolders(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetMajorHolders"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get mutual fund holders of a stock
		 * @summary Get Mutualfund Holders
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetMutualfundHolders(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetMutualfundHolders(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap[
					"YahooFinanceApi.yahooFinanceGetMutualfundHolders"
				]?.[localVarOperationServerIndex]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get options of a stock
		 * @summary Get Options
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetOptions(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetOptions(symbol, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetOptions"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get stock price of a stock
		 * @summary Get Price
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetPrice(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetPrice(symbol, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetPrice"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get quote of a stock
		 * @summary Get Quote
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetQuote(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetQuote(symbol, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetQuote"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get recommendations of a stock
		 * @summary Get Recommendations
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetRecommendations(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetRecommendations(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetRecommendations"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get splits of a stock
		 * @summary Get Splits
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetSplits(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetSplits(symbol, options);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetSplits"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
		/**
		 * Get sustainability of a stock
		 * @summary Get Sustainability
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async yahooFinanceGetSustainability(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.yahooFinanceGetSustainability(
					symbol,
					options,
				);
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
			const localVarOperationServerBasePath =
				operationServerMap["YahooFinanceApi.yahooFinanceGetSustainability"]?.[
					localVarOperationServerIndex
				]?.url;
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration,
				)(axios, localVarOperationServerBasePath || basePath);
		},
	};
};

/**
 * YahooFinanceApi - factory interface
 * @export
 */
export const YahooFinanceApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance,
) {
	const localVarFp = YahooFinanceApiFp(configuration);
	return {
		/**
		 * Get actions of a stock
		 * @summary Get Actions
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetActions(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetActions(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get balance sheet of a stock
		 * @summary Get Balance Sheet
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetBalanceSheet(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetBalanceSheet(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get cashflow of a stock
		 * @summary Get Cashflow
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetCashflow(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetCashflow(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get company overview of a stock
		 * @summary Get Company Overview
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetCompanyOverview(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetCompanyOverview(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get dividends of a stock
		 * @summary Get Dividends
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetDividends(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetDividends(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get earnings of a stock
		 * @summary Get Earnings
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetEarnings(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetEarnings(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get earnings calendar of a stock
		 * @summary Get Earnings Calendar
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetEarningsCalendar(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetEarningsCalendar(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get financials of a stock
		 * @summary Get Financials
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetFinancials(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetFinancials(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get stock history of a stock
		 * @summary Get History
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetHistory(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetHistory(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get info of a stock
		 * @summary Get Info
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetInfo(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetInfo(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get institutional holders of a stock
		 * @summary Get Institutional Holders
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetInstitutionalHolders(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetInstitutionalHolders(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get major holders of a stock
		 * @summary Get Major Holders
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetMajorHolders(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetMajorHolders(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get mutual fund holders of a stock
		 * @summary Get Mutualfund Holders
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetMutualfundHolders(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetMutualfundHolders(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get options of a stock
		 * @summary Get Options
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetOptions(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetOptions(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get stock price of a stock
		 * @summary Get Price
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetPrice(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetPrice(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get quote of a stock
		 * @summary Get Quote
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetQuote(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetQuote(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get recommendations of a stock
		 * @summary Get Recommendations
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetRecommendations(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetRecommendations(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get splits of a stock
		 * @summary Get Splits
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetSplits(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetSplits(symbol, options)
				.then((request) => request(axios, basePath));
		},
		/**
		 * Get sustainability of a stock
		 * @summary Get Sustainability
		 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		yahooFinanceGetSustainability(
			symbol: string,
			options?: RawAxiosRequestConfig,
		): AxiosPromise<object> {
			return localVarFp
				.yahooFinanceGetSustainability(symbol, options)
				.then((request) => request(axios, basePath));
		},
	};
};

/**
 * YahooFinanceApi - object-oriented interface
 * @export
 * @class YahooFinanceApi
 * @extends {BaseAPI}
 */
export class YahooFinanceApi extends BaseAPI {
	/**
	 * Get actions of a stock
	 * @summary Get Actions
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetActions(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetActions(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get balance sheet of a stock
	 * @summary Get Balance Sheet
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetBalanceSheet(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetBalanceSheet(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get cashflow of a stock
	 * @summary Get Cashflow
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetCashflow(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetCashflow(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get company overview of a stock
	 * @summary Get Company Overview
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetCompanyOverview(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetCompanyOverview(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get dividends of a stock
	 * @summary Get Dividends
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetDividends(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetDividends(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get earnings of a stock
	 * @summary Get Earnings
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetEarnings(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetEarnings(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get earnings calendar of a stock
	 * @summary Get Earnings Calendar
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetEarningsCalendar(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetEarningsCalendar(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get financials of a stock
	 * @summary Get Financials
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetFinancials(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetFinancials(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get stock history of a stock
	 * @summary Get History
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetHistory(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetHistory(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get info of a stock
	 * @summary Get Info
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetInfo(symbol: string, options?: RawAxiosRequestConfig) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetInfo(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get institutional holders of a stock
	 * @summary Get Institutional Holders
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetInstitutionalHolders(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetInstitutionalHolders(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get major holders of a stock
	 * @summary Get Major Holders
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetMajorHolders(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetMajorHolders(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get mutual fund holders of a stock
	 * @summary Get Mutualfund Holders
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetMutualfundHolders(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetMutualfundHolders(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get options of a stock
	 * @summary Get Options
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetOptions(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetOptions(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get stock price of a stock
	 * @summary Get Price
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetPrice(symbol: string, options?: RawAxiosRequestConfig) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetPrice(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get quote of a stock
	 * @summary Get Quote
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetQuote(symbol: string, options?: RawAxiosRequestConfig) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetQuote(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get recommendations of a stock
	 * @summary Get Recommendations
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetRecommendations(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetRecommendations(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get splits of a stock
	 * @summary Get Splits
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetSplits(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetSplits(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 * Get sustainability of a stock
	 * @summary Get Sustainability
	 * @param {string} symbol Stock ticker symbol (e.g. \&#39;AAPL\&#39;)
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof YahooFinanceApi
	 */
	public yahooFinanceGetSustainability(
		symbol: string,
		options?: RawAxiosRequestConfig,
	) {
		return YahooFinanceApiFp(this.configuration)
			.yahooFinanceGetSustainability(symbol, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
